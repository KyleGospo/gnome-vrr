From 439de8fb876118bacde92000dab4e919e1e49a02 Mon Sep 17 00:00:00 2001
From: Austin Shafer <ashafer@badland.io>
Date: Tue, 5 Sep 2023 10:46:19 -0400
Subject: [PATCH 1/6] Pass surface arg to meta_wayland_dma_buf_create_source

---
 src/wayland/meta-wayland-dma-buf.c     | 3 +++
 src/wayland/meta-wayland-dma-buf.h     | 1 +
 src/wayland/meta-wayland-transaction.c | 6 ++++--
 3 files changed, 8 insertions(+), 2 deletions(-)

diff --git a/src/wayland/meta-wayland-dma-buf.c b/src/wayland/meta-wayland-dma-buf.c
index 79a0f1409..8e9993898 100644
--- a/src/wayland/meta-wayland-dma-buf.c
+++ b/src/wayland/meta-wayland-dma-buf.c
@@ -843,6 +843,7 @@ typedef struct _MetaWaylandDmaBufSource
 
   MetaWaylandDmaBufSourceDispatch dispatch;
   MetaWaylandBuffer *buffer;
+  MetaWaylandSurface *surface;
   gpointer user_data;
 
   gpointer fd_tags[META_WAYLAND_DMA_BUF_MAX_FDS];
@@ -944,6 +945,7 @@ static GSourceFuncs meta_wayland_dma_buf_source_funcs = {
  */
 GSource *
 meta_wayland_dma_buf_create_source (MetaWaylandBuffer               *buffer,
+                                    MetaWaylandSurface              *surface,
                                     MetaWaylandDmaBufSourceDispatch  dispatch,
                                     gpointer                         user_data)
 {
@@ -972,6 +974,7 @@ meta_wayland_dma_buf_create_source (MetaWaylandBuffer               *buffer,
                                                       sizeof (*source));
           source->buffer = g_object_ref (buffer);
           source->dispatch = dispatch;
+          source->surface = surface;
           source->user_data = user_data;
         }
 
diff --git a/src/wayland/meta-wayland-dma-buf.h b/src/wayland/meta-wayland-dma-buf.h
index 1c03acb32..154937418 100644
--- a/src/wayland/meta-wayland-dma-buf.h
+++ b/src/wayland/meta-wayland-dma-buf.h
@@ -60,6 +60,7 @@ typedef void (*MetaWaylandDmaBufSourceDispatch) (MetaWaylandBuffer *buffer,
 
 GSource *
 meta_wayland_dma_buf_create_source (MetaWaylandBuffer               *buffer,
+                                    MetaWaylandSurface              *surface,
                                     MetaWaylandDmaBufSourceDispatch  dispatch,
                                     gpointer                         user_data);
 
diff --git a/src/wayland/meta-wayland-transaction.c b/src/wayland/meta-wayland-transaction.c
index 9b999bfa9..0568ba3e0 100644
--- a/src/wayland/meta-wayland-transaction.c
+++ b/src/wayland/meta-wayland-transaction.c
@@ -289,7 +289,8 @@ meta_wayland_transaction_dma_buf_dispatch (MetaWaylandBuffer *buffer,
 
 static gboolean
 meta_wayland_transaction_add_dma_buf_source (MetaWaylandTransaction *transaction,
-                                             MetaWaylandBuffer      *buffer)
+                                             MetaWaylandBuffer      *buffer,
+                                             MetaWaylandSurface     *surface)
 {
   GSource *source;
 
@@ -298,6 +299,7 @@ meta_wayland_transaction_add_dma_buf_source (MetaWaylandTransaction *transaction
     return FALSE;
 
   source = meta_wayland_dma_buf_create_source (buffer,
+                                               surface,
                                                meta_wayland_transaction_dma_buf_dispatch,
                                                transaction);
   if (!source)
@@ -336,7 +338,7 @@ meta_wayland_transaction_commit (MetaWaylandTransaction *transaction)
           MetaWaylandBuffer *buffer = entry->state->buffer;
 
           if (buffer &&
-              meta_wayland_transaction_add_dma_buf_source (transaction, buffer))
+              meta_wayland_transaction_add_dma_buf_source (transaction, buffer, surface))
             maybe_apply = FALSE;
         }
     }
-- 
2.42.0


From 7f30fc2828779864991cc67d5a21f93c7227cf49 Mon Sep 17 00:00:00 2001
From: Austin Shafer <ashafer@badland.io>
Date: Thu, 26 Oct 2023 13:33:34 -0400
Subject: [PATCH 2/6] cogl: Store latest GPU work completed sync fd

This keeps an internal sync_fd for the latest work submitted to
the GPU. This can then be fetched with cogl_context_get_latest_sync_fd
for use. This is intended for use with linux-drm-syncobj-v1
---
 cogl/cogl/cogl-context-private.h              |  6 ++++
 cogl/cogl/cogl-context.c                      | 28 +++++++++++++++++++
 cogl/cogl/cogl-context.h                      | 14 ++++++++++
 cogl/cogl/cogl-framebuffer.c                  |  3 ++
 cogl/cogl/driver/gl/cogl-util-gl.c            |  3 ++
 .../cogl-winsys-egl-feature-functions.h       |  9 ++++++
 cogl/cogl/winsys/cogl-winsys-egl.c            | 20 +++++++++++++
 cogl/cogl/winsys/cogl-winsys-private.h        |  3 ++
 8 files changed, 86 insertions(+)

diff --git a/cogl/cogl/cogl-context-private.h b/cogl/cogl/cogl-context-private.h
index 502dda72b..af45215f2 100644
--- a/cogl/cogl/cogl-context-private.h
+++ b/cogl/cogl/cogl-context-private.h
@@ -257,6 +257,9 @@ struct _CoglContext
   CoglPollSource *fences_poll_source;
   CoglList fences;
 
+  /* fd representing the last submitted GPU work */
+  int sync_fd;
+
   GHashTable *named_pipelines;
 
   /* This defines a list of function pointers that Cogl uses from
@@ -311,3 +314,6 @@ _cogl_context_set_current_projection_entry (CoglContext *context,
 void
 _cogl_context_set_current_modelview_entry (CoglContext *context,
                                            CoglMatrixEntry *entry);
+
+void
+_cogl_context_update_sync_fd (CoglContext *context);
diff --git a/cogl/cogl/cogl-context.c b/cogl/cogl/cogl-context.c
index f7d276825..14ed0a1bd 100644
--- a/cogl/cogl/cogl-context.c
+++ b/cogl/cogl/cogl-context.c
@@ -458,6 +458,20 @@ _cogl_context_set_current_modelview_entry (CoglContext *context,
   context->current_modelview_entry = entry;
 }
 
+void
+_cogl_context_update_sync_fd (CoglContext *context)
+{
+  const CoglWinsysVtable *winsys = _cogl_context_get_winsys (context);
+
+  if (!winsys->get_sync_fd)
+    return;
+
+  if (context->sync_fd >= 0)
+    close (context->sync_fd);
+
+  context->sync_fd = winsys->get_sync_fd (context);
+}
+
 CoglGraphicsResetStatus
 cogl_get_graphics_reset_status (CoglContext *context)
 {
@@ -531,3 +545,17 @@ cogl_context_get_gpu_time_ns (CoglContext *context)
 
   return context->driver_vtable->get_gpu_time_ns (context);
 }
+
+int
+cogl_context_get_latest_sync_fd (CoglContext *context)
+{
+  const CoglWinsysVtable *winsys = _cogl_context_get_winsys (context);
+
+  if (!winsys->get_sync_fd)
+    return -1;
+
+  if (context->sync_fd >= 0)
+    return dup(context->sync_fd);
+
+  return -1;
+}
diff --git a/cogl/cogl/cogl-context.h b/cogl/cogl/cogl-context.h
index 8ad691420..847da576a 100644
--- a/cogl/cogl/cogl-context.h
+++ b/cogl/cogl/cogl-context.h
@@ -368,4 +368,18 @@ cogl_context_timestamp_query_get_time_ns (CoglContext        *context,
 COGL_EXPORT int64_t
 cogl_context_get_gpu_time_ns (CoglContext *context);
 
+/**
+ * cogl_context_get_latest_sync_fd
+ * @context: a #CoglContext pointer
+ *
+ * This function is used to get support for waiting on previous
+ * GPU work through sync fds. It will return a sync fd which will
+ * signal when the previous work has completed.
+ *
+ * Return value: sync fd for latest GPU submission if available,
+ * returns -1 if not.
+ */
+COGL_EXPORT int
+cogl_context_get_latest_sync_fd (CoglContext *context);
+
 G_END_DECLS
diff --git a/cogl/cogl/cogl-framebuffer.c b/cogl/cogl/cogl-framebuffer.c
index f0499f31a..5f29f8591 100644
--- a/cogl/cogl/cogl-framebuffer.c
+++ b/cogl/cogl/cogl-framebuffer.c
@@ -1710,6 +1710,9 @@ cogl_framebuffer_flush (CoglFramebuffer *framebuffer)
   CoglFramebufferPrivate *priv =
     cogl_framebuffer_get_instance_private (framebuffer);
 
+  /* Update our "latest" sync fd to contain all previous work */
+  _cogl_context_update_sync_fd (priv->context);
+
   _cogl_framebuffer_flush_journal (framebuffer);
 
   cogl_framebuffer_driver_flush (priv->driver);
diff --git a/cogl/cogl/driver/gl/cogl-util-gl.c b/cogl/cogl/driver/gl/cogl-util-gl.c
index c22444265..ab237e04a 100644
--- a/cogl/cogl/driver/gl/cogl-util-gl.c
+++ b/cogl/cogl/driver/gl/cogl-util-gl.c
@@ -519,6 +519,9 @@ cogl_gl_create_timestamp_query (CoglContext *context)
   GE (context, glGenQueries (1, &query->id));
   GE (context, glQueryCounter (query->id, GL_TIMESTAMP));
 
+  /* Update our "latest" sync fd to contain all previous work */
+  _cogl_context_update_sync_fd (context);
+
   /* Flush right away so GL knows about our timestamp query.
    *
    * E.g. the direct scanout path doesn't call SwapBuffers or any other
diff --git a/cogl/cogl/winsys/cogl-winsys-egl-feature-functions.h b/cogl/cogl/winsys/cogl-winsys-egl-feature-functions.h
index 494d5ea39..78a590320 100644
--- a/cogl/cogl/winsys/cogl-winsys-egl-feature-functions.h
+++ b/cogl/cogl/winsys/cogl-winsys-egl-feature-functions.h
@@ -156,6 +156,15 @@ COGL_WINSYS_FEATURE_FUNCTION (EGLBoolean, eglDestroySync,
                               (EGLDisplay dpy,
                                EGLSyncKHR sync))
 COGL_WINSYS_FEATURE_END ()
+
+COGL_WINSYS_FEATURE_BEGIN (dup_native_fence_fd,
+                           "ANDROID\0",
+                           "dup_native_fence_fd\0",
+                           COGL_EGL_WINSYS_FEATURE_FENCE_SYNC)
+COGL_WINSYS_FEATURE_FUNCTION (EGLint, eglDupNativeFenceFD,
+                              (EGLDisplay dpy,
+                               EGLSyncKHR sync))
+COGL_WINSYS_FEATURE_END ()
 #endif
 
 COGL_WINSYS_FEATURE_BEGIN (surfaceless_context,
diff --git a/cogl/cogl/winsys/cogl-winsys-egl.c b/cogl/cogl/winsys/cogl-winsys-egl.c
index 28aa0a268..a6f5b04a3 100644
--- a/cogl/cogl/winsys/cogl-winsys-egl.c
+++ b/cogl/cogl/winsys/cogl-winsys-egl.c
@@ -614,6 +614,25 @@ _cogl_winsys_fence_destroy (CoglContext *context, void *fence)
 
   renderer->pf_eglDestroySync (renderer->edpy, fence);
 }
+
+static int
+_cogl_winsys_get_sync_fd (CoglContext *context)
+{
+  CoglRendererEGL *renderer = context->display->renderer->winsys;
+  EGLSyncKHR sync;
+  int fd;
+
+  sync = renderer->pf_eglCreateSync (renderer->edpy, EGL_SYNC_NATIVE_FENCE_ANDROID, NULL);
+  if (sync == EGL_NO_SYNC_KHR)
+    return -1;
+
+  fd = renderer->pf_eglDupNativeFenceFD (renderer->edpy, sync);
+  renderer->pf_eglDestroySync (renderer->edpy, sync);
+  if (fd == EGL_NO_NATIVE_FENCE_FD_ANDROID)
+    return -1;
+
+  return fd;
+}
 #endif
 
 static CoglWinsysVtable _cogl_winsys_vtable =
@@ -636,6 +655,7 @@ static CoglWinsysVtable _cogl_winsys_vtable =
     .fence_add = _cogl_winsys_fence_add,
     .fence_is_complete = _cogl_winsys_fence_is_complete,
     .fence_destroy = _cogl_winsys_fence_destroy,
+    .get_sync_fd = _cogl_winsys_get_sync_fd,
 #endif
   };
 
diff --git a/cogl/cogl/winsys/cogl-winsys-private.h b/cogl/cogl/winsys/cogl-winsys-private.h
index d414cada0..c5a69776a 100644
--- a/cogl/cogl/winsys/cogl-winsys-private.h
+++ b/cogl/cogl/winsys/cogl-winsys-private.h
@@ -144,6 +144,9 @@ typedef struct _CoglWinsysVtable
   (*fence_destroy) (CoglContext *ctx,
                     void        *fence);
 
+  int
+  (*get_sync_fd) (CoglContext *ctx);
+
 } CoglWinsysVtable;
 
 typedef const CoglWinsysVtable *(*CoglWinsysVtableGetter) (void);
-- 
2.42.0


From 83c99dc360dae6af3bdf8158a984995b1fd4e74b Mon Sep 17 00:00:00 2001
From: Austin Shafer <ashafer@badland.io>
Date: Wed, 6 Sep 2023 13:06:54 -0400
Subject: [PATCH 3/6] Add MetaDrmTimeline

This abstracts away directly dealing with DRM syncobjs. Explicit
sync code can simply create a MetaDrmTimeline and request an fd at
a particular sync point.
---
 meson.build                     |   3 +
 src/meson.build                 |   2 +
 src/wayland/meta-drm-timeline.c | 259 ++++++++++++++++++++++++++++++++
 src/wayland/meta-drm-timeline.h |  49 ++++++
 4 files changed, 313 insertions(+)
 create mode 100644 src/wayland/meta-drm-timeline.c
 create mode 100644 src/wayland/meta-drm-timeline.h

diff --git a/meson.build b/meson.build
index f513c2b55..53e6aca42 100644
--- a/meson.build
+++ b/meson.build
@@ -322,6 +322,8 @@ if have_introspection
   ]
 endif
 
+have_eventfd = cc.has_header('sys/eventfd.h')
+
 have_documentation = get_option('docs')
 if have_documentation
   gidocgen_dep = dependency('gi-docgen', version: '>= 2021.1',
@@ -541,6 +543,7 @@ cdata.set('HAVE_STARTUP_NOTIFICATION', have_startup_notification)
 cdata.set('HAVE_INTROSPECTION', have_introspection)
 cdata.set('HAVE_PROFILER', have_profiler)
 cdata.set('HAVE_LIBDISPLAY_INFO', have_libdisplay_info)
+cdata.set('HAVE_EVENTFD', have_eventfd)
 
 if have_x11_client
   xkb_base = xkeyboard_config_dep.get_variable('xkb_base')
diff --git a/src/meson.build b/src/meson.build
index ca2ef166c..87ff43af2 100644
--- a/src/meson.build
+++ b/src/meson.build
@@ -589,6 +589,8 @@ if have_wayland
     'core/meta-service-channel.h',
     'wayland/meta-cursor-sprite-wayland.c',
     'wayland/meta-cursor-sprite-wayland.h',
+    'wayland/meta-drm-timeline.c',
+    'wayland/meta-drm-timeline.h',
     'wayland/meta-pointer-confinement-wayland.c',
     'wayland/meta-pointer-confinement-wayland.h',
     'wayland/meta-pointer-lock-wayland.c',
diff --git a/src/wayland/meta-drm-timeline.c b/src/wayland/meta-drm-timeline.c
new file mode 100644
index 000000000..91bc86330
--- /dev/null
+++ b/src/wayland/meta-drm-timeline.c
@@ -0,0 +1,259 @@
+/*
+ * Copyright (C) 2023 NVIDIA Corporation.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of the
+ * License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, see <http://www.gnu.org/licenses/>.
+ *
+ * Written by:
+ *     Austin Shafer <ashafer@nvidia.com>
+ */
+
+/**
+ * MetaDrmTimeline
+ *
+ * MetaDrmTimeline is a helper for handling DRM syncobj operations. It
+ * can import DRM syncobjs and export eventfds at a particular point.
+ *
+ * This is heavily inspired by wlroot's wlr_render_timeline, written by
+ * Simon Ser.
+ */
+
+#include "config.h"
+
+#include <xf86drm.h>
+#ifdef HAVE_EVENTFD
+#include <sys/eventfd.h>
+#endif
+
+#include "meta/util.h"
+#include "wayland/meta-drm-timeline.h"
+
+enum
+{
+  PROP_0,
+
+  PROP_DRM_FD,
+  PROP_SYNCOBJ_FD,
+
+  N_PROPS
+};
+
+typedef struct _MetaDrmTimeline
+{
+  GObject parent;
+
+  int drm;
+  int drm_syncobj_fd;
+  uint32_t drm_syncobj;
+} MetaDrmTimeline;
+
+static GParamSpec *obj_props[N_PROPS];
+
+static void initable_iface_init (GInitableIface *initable_iface);
+
+G_DEFINE_TYPE_WITH_CODE (MetaDrmTimeline, meta_drm_timeline, G_TYPE_OBJECT,
+                         G_IMPLEMENT_INTERFACE (G_TYPE_INITABLE,
+                                                initable_iface_init))
+
+static void
+meta_drm_timeline_get_property (GObject    *object,
+                                guint       prop_id,
+                                GValue     *value,
+                                GParamSpec *pspec)
+{
+  MetaDrmTimeline *timeline = META_DRM_TIMELINE (object);
+
+  switch (prop_id)
+    {
+    case PROP_DRM_FD:
+      g_value_set_int (value, timeline->drm);
+      break;
+    case PROP_SYNCOBJ_FD:
+      g_value_set_int (value, timeline->drm_syncobj_fd);
+      break;
+    default:
+      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
+      break;
+    }
+}
+
+static void
+meta_drm_timeline_set_property (GObject      *object,
+                                guint         prop_id,
+                                const GValue *value,
+                                GParamSpec   *pspec)
+{
+  MetaDrmTimeline *timeline = META_DRM_TIMELINE (object);
+  int fd;
+
+  switch (prop_id)
+    {
+    case PROP_DRM_FD:
+      fd = g_value_get_int (value);
+      timeline->drm = dup (fd);
+      break;
+    case PROP_SYNCOBJ_FD:
+      fd = g_value_get_int (value);
+      timeline->drm_syncobj_fd = dup (fd);
+      break;
+    default:
+      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
+      break;
+    }
+}
+
+static gboolean
+meta_drm_timeline_initable_init (GInitable     *initable,
+                                 GCancellable  *cancellable,
+                                 GError       **error)
+{
+  MetaDrmTimeline *timeline = META_DRM_TIMELINE (initable);
+
+  if (drmSyncobjFDToHandle (timeline->drm, timeline->drm_syncobj_fd,
+                            &timeline->drm_syncobj) != 0)
+    {
+      g_set_error (error, G_IO_ERROR,
+                   G_IO_ERROR_FAILED,
+        "Failed to import DRM syncobj");
+      return FALSE;
+    }
+
+  return TRUE;
+}
+
+static void
+initable_iface_init (GInitableIface *initable_iface)
+{
+  initable_iface->init = meta_drm_timeline_initable_init;
+}
+
+MetaDrmTimeline *
+meta_drm_timeline_import_syncobj (int       fd,
+                                  int       drm_syncobj,
+                                  GError  **error)
+{
+  MetaDrmTimeline *timeline = g_initable_new (META_TYPE_DRM_TIMELINE,
+                                              NULL, error,
+                                              "drm-fd", fd,
+                                              "syncobj-fd", drm_syncobj,
+                                              NULL);
+
+  return timeline;
+}
+
+int
+meta_drm_timeline_get_eventfd (MetaDrmTimeline *timeline,
+                               uint64_t         sync_point,
+                               GError         **error)
+{
+  int fd = -1;
+#ifdef HAVE_EVENTFD
+  struct drm_syncobj_eventfd syncobj_eventfd;
+
+  fd = eventfd (0, EFD_CLOEXEC);
+  if (fd < 0)
+    return -1;
+
+  syncobj_eventfd = {
+    .handle = timeline->drm_syncobj,
+    .flags = 0,
+    .point = sync_point,
+    .fd = fd,
+  };
+
+  if (drmIoctl (timeline->drm, DRM_IOCTL_SYNCOBJ_EVENTFD, &syncobj_eventfd) != 0)
+    {
+      g_set_error (error, G_IO_ERROR, G_IO_ERROR_NOT_SUPPORTED,
+                   "DRM_IOCTL_SYNCOBJ_EVENTFD: Failed to export eventfd");
+      close (fd);
+      return -1;
+    }
+
+#endif
+  return fd;
+}
+
+int
+meta_drm_timeline_set_sync_point (MetaDrmTimeline *timeline,
+                                  uint64_t         sync_point,
+                                  int              sync_fd,
+                                  GError         **error)
+{
+  int fd = -1;
+#ifdef HAVE_EVENTFD
+  fd = eventfd (0, EFD_CLOEXEC);
+  if (fd < 0)
+    return -1;
+
+  if (drmSyncobjImportSyncFileTimeline (timeline->drm, timeline->drm_syncobj,
+                                        sync_fd, sync_point))
+    {
+      g_set_error (error, G_IO_ERROR, G_IO_ERROR_NOT_SUPPORTED,
+                   "DRM_IOCTL_SYNCOBJ_IMPORT: Failed to import syncfd");
+      close (fd);
+      return -1;
+    }
+
+#endif
+  return fd;
+}
+
+static void
+meta_drm_timeline_finalize (GObject *object)
+{
+  MetaDrmTimeline *timeline = META_DRM_TIMELINE (object);
+
+  drmSyncobjDestroy (timeline->drm, timeline->drm_syncobj);
+  close (timeline->drm_syncobj_fd);
+  close (timeline->drm);
+
+  G_OBJECT_CLASS (meta_drm_timeline_parent_class)->finalize (object);
+}
+
+static void
+meta_drm_timeline_init (MetaDrmTimeline *timeline)
+{
+  timeline->drm  = -1;
+  timeline->drm_syncobj_fd = -1;
+  timeline->drm_syncobj = -1;
+}
+
+static void
+meta_drm_timeline_class_init (MetaDrmTimelineClass *klass)
+{
+  GObjectClass *object_class = G_OBJECT_CLASS (klass);
+
+  object_class->get_property = meta_drm_timeline_get_property;
+  object_class->set_property = meta_drm_timeline_set_property;
+  object_class->finalize = meta_drm_timeline_finalize;
+
+  obj_props[PROP_DRM_FD] =
+    g_param_spec_object ("drm-fd",
+                         "drm-fd",
+                         "DRM fd",
+                         FALSE,
+                         G_PARAM_READWRITE |
+                         G_PARAM_CONSTRUCT_ONLY |
+                         G_PARAM_STATIC_STRINGS);
+
+  obj_props[PROP_SYNCOBJ_FD] =
+    g_param_spec_object ("syncobj-fd",
+                         "syncobj-fd",
+                         "DRM Syncobj fd",
+                         FALSE,
+                         G_PARAM_READWRITE |
+                         G_PARAM_CONSTRUCT_ONLY |
+                         G_PARAM_STATIC_STRINGS);
+
+  g_object_class_install_properties (object_class, N_PROPS, obj_props);
+}
diff --git a/src/wayland/meta-drm-timeline.h b/src/wayland/meta-drm-timeline.h
new file mode 100644
index 000000000..bbe85b47a
--- /dev/null
+++ b/src/wayland/meta-drm-timeline.h
@@ -0,0 +1,49 @@
+/* -*- mode: C; c-file-style: "gnu"; indent-tabs-mode: nil; -*- */
+
+/*
+ * Copyright (C) 2023 NVIDIA Corporation.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of the
+ * License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, see <http://www.gnu.org/licenses/>.
+ *
+ * Written by:
+ *     Austin Shafer <ashafer@nvidia.com>
+ */
+
+#pragma once
+
+#include <glib.h>
+#include <glib-object.h>
+#include <stdint.h>
+
+#define META_TYPE_DRM_TIMELINE (meta_drm_timeline_get_type ())
+G_DECLARE_FINAL_TYPE (MetaDrmTimeline, meta_drm_timeline,
+                      META, DRM_TIMELINE, GObject);
+
+typedef struct _MetaDrmTimeline MetaDrmTimeline;
+
+MetaDrmTimeline *meta_drm_timeline_create (int fd,
+                                           GError **error);
+
+MetaDrmTimeline *meta_drm_timeline_import_syncobj (int       fd,
+                                                   int       drm_syncobj,
+                                                   GError  **error);
+
+int meta_drm_timeline_get_eventfd (MetaDrmTimeline *timeline,
+                                   uint64_t         sync_point,
+                                   GError  **error);
+
+int meta_drm_timeline_set_sync_point (MetaDrmTimeline *timeline,
+                                      uint64_t         sync_point,
+                                      int              sync_fd,
+                                      GError         **error);
-- 
2.42.0


From 704e34c5244ea6dd98188ccab0ac2e6d11b791d9 Mon Sep 17 00:00:00 2001
From: Austin Shafer <ashafer@badland.io>
Date: Thu, 7 Sep 2023 10:32:21 -0400
Subject: [PATCH 4/6] Add linux-drm-syncobj v1 to build

---
 src/meson.build | 1 +
 1 file changed, 1 insertion(+)

diff --git a/src/meson.build b/src/meson.build
index 87ff43af2..d9c86cf38 100644
--- a/src/meson.build
+++ b/src/meson.build
@@ -1082,6 +1082,7 @@ if have_wayland
     ['xdg-output', 'unstable', 'v1', ],
     ['xdg-shell', 'stable', ],
     ['xwayland-keyboard-grab', 'unstable', 'v1', ],
+    ['linux-drm-syncobj', 'staging', 'v1'],
   ]
   if have_wayland_eglstream
     wayland_eglstream_protocols_dir = wayland_eglstream_protocols_dep.get_variable('pkgdatadir')
-- 
2.42.0


From 1a78a57dd4e39f3af0dc2dbab10ade02970698a6 Mon Sep 17 00:00:00 2001
From: Austin Shafer <ashafer@badland.io>
Date: Fri, 8 Sep 2023 16:40:56 -0400
Subject: [PATCH 5/6] Implement linux-drm-syncobj-v1

---
 src/meson.build                              |   2 +
 src/wayland/meta-wayland-buffer.c            |  31 +-
 src/wayland/meta-wayland-buffer.h            |   2 +
 src/wayland/meta-wayland-linux-drm-syncobj.c | 413 +++++++++++++++++++
 src/wayland/meta-wayland-linux-drm-syncobj.h |  62 +++
 src/wayland/meta-wayland-surface.c           |  49 +++
 src/wayland/meta-wayland-surface.h           |  19 +
 src/wayland/meta-wayland-types.h             |   3 +
 src/wayland/meta-wayland.c                   |   2 +
 9 files changed, 582 insertions(+), 1 deletion(-)
 create mode 100644 src/wayland/meta-wayland-linux-drm-syncobj.c
 create mode 100644 src/wayland/meta-wayland-linux-drm-syncobj.h

diff --git a/src/meson.build b/src/meson.build
index d9c86cf38..1869c2b1d 100644
--- a/src/meson.build
+++ b/src/meson.build
@@ -643,6 +643,8 @@ if have_wayland
     'wayland/meta-wayland-keyboard.h',
     'wayland/meta-wayland-legacy-xdg-foreign.c',
     'wayland/meta-wayland-legacy-xdg-foreign.h',
+    'wayland/meta-wayland-linux-drm-syncobj.c',
+    'wayland/meta-wayland-linux-drm-syncobj.h',
     'wayland/meta-wayland-outputs.c',
     'wayland/meta-wayland-outputs.h',
     'wayland/meta-wayland-pointer.c',
diff --git a/src/wayland/meta-wayland-buffer.c b/src/wayland/meta-wayland-buffer.c
index 7a9858010..1006c0a47 100644
--- a/src/wayland/meta-wayland-buffer.c
+++ b/src/wayland/meta-wayland-buffer.c
@@ -56,6 +56,8 @@
 #include "meta/util.h"
 #include "wayland/meta-wayland-dma-buf.h"
 #include "wayland/meta-wayland-private.h"
+#include "wayland/meta-drm-timeline.h"
+#include "wayland/meta-wayland-linux-drm-syncobj.h"
 
 #ifdef HAVE_NATIVE_BACKEND
 #include "backends/native/meta-drm-buffer-gbm.h"
@@ -661,12 +663,36 @@ meta_wayland_buffer_inc_use_count (MetaWaylandBuffer *buffer)
 void
 meta_wayland_buffer_dec_use_count (MetaWaylandBuffer *buffer)
 {
+  MetaContext *context = meta_wayland_compositor_get_context (buffer->compositor);
+  MetaBackend *backend = meta_context_get_backend (context);
+  ClutterBackend *clutter_backend = meta_backend_get_clutter_backend (backend);
+  CoglContext *cogl_context = clutter_backend_get_cogl_context (clutter_backend);
+  MetaWaylandSyncPoint *sync_point;
+  GError *error = NULL;
+  int sync_fd;
+
   g_return_if_fail (buffer->use_count > 0);
 
   buffer->use_count--;
 
   if (buffer->use_count == 0 && buffer->resource)
-    wl_buffer_send_release (buffer->resource);
+    {
+      wl_buffer_send_release (buffer->resource);
+
+      sync_fd = cogl_context_get_latest_sync_fd (cogl_context);
+      g_return_if_fail (sync_fd < 0);
+      for (int i = 0; i < buffer->release_points->len; i++)
+        {
+          sync_point = g_array_index (buffer->release_points, MetaWaylandSyncPoint *, i);
+          meta_drm_timeline_set_sync_point (sync_point->timeline->drm_timeline,
+              sync_point->sync_point, sync_fd, &error);
+          if (error)
+            {
+              g_warning ("Failed to import sync point: %s", error ? error->message : "Unknown error");
+              g_clear_pointer (&error, g_free);
+            }
+        }
+    }
 }
 
 gboolean
@@ -875,6 +901,7 @@ meta_wayland_buffer_finalize (GObject *object)
 
   clear_tainted_scanout_onscreens (buffer);
   g_clear_pointer (&buffer->tainted_scanout_onscreens, g_hash_table_unref);
+  g_clear_pointer (&buffer->release_points, g_array_unref);
 
   g_clear_object (&buffer->egl_image.texture);
 #ifdef HAVE_WAYLAND_EGLSTREAM
@@ -893,6 +920,8 @@ meta_wayland_buffer_finalize (GObject *object)
 static void
 meta_wayland_buffer_init (MetaWaylandBuffer *buffer)
 {
+  buffer->release_points = g_array_new (FALSE, FALSE, sizeof (MetaWaylandSyncPoint *));
+  g_array_set_clear_func (buffer->release_points, (GDestroyNotify) g_object_unref);
 }
 
 static void
diff --git a/src/wayland/meta-wayland-buffer.h b/src/wayland/meta-wayland-buffer.h
index 2b50c2539..8505213ed 100644
--- a/src/wayland/meta-wayland-buffer.h
+++ b/src/wayland/meta-wayland-buffer.h
@@ -80,6 +80,8 @@ struct _MetaWaylandBuffer
   } single_pixel;
 
   GHashTable *tainted_scanout_onscreens;
+
+  GArray *release_points;
 };
 
 #define META_TYPE_WAYLAND_BUFFER (meta_wayland_buffer_get_type ())
diff --git a/src/wayland/meta-wayland-linux-drm-syncobj.c b/src/wayland/meta-wayland-linux-drm-syncobj.c
new file mode 100644
index 000000000..8ac510680
--- /dev/null
+++ b/src/wayland/meta-wayland-linux-drm-syncobj.c
@@ -0,0 +1,413 @@
+/*
+ * Copyright (C) 2023 NVIDIA Corporation.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of the
+ * License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, see <http://www.gnu.org/licenses/>.
+ *
+ * Written by:
+ *     Austin Shafer <ashafer@nvidia.com>
+ */
+
+#include "config.h"
+
+#include "meta/util.h"
+#include "wayland/meta-wayland-private.h"
+#include "wayland/meta-wayland-linux-drm-syncobj.h"
+#include "backends/native/meta-backend-native-types.h"
+#include "backends/native/meta-renderer-native.h"
+#include "backends/native/meta-device-pool.h"
+
+#include "linux-drm-syncobj-v1-server-protocol.h"
+
+typedef struct _MetaWaylandDrmSyncobjManager
+{
+  GObject parent;
+
+  // TODO: Needs multi-GPU handling?
+  int drm;
+} MetaWaylandDrmSyncobjManager;
+
+typedef struct _MetaWaylandSyncobjSurface
+{
+  GObject parent;
+
+  struct wl_resource *resource;
+  MetaWaylandSurface *surface;
+} MetaWaylandSyncobjSurface;
+
+static void
+syncobj_surface_handle_destroy (struct wl_client *client,
+                             struct wl_resource *resource);
+static void
+syncobj_surface_handle_set_acquire_point (struct wl_client *client, struct wl_resource *resource,
+                                       struct wl_resource *timeline_resource, uint32_t point_hi,
+                                       uint32_t point_lo);
+static void syncobj_surface_handle_set_release_point (struct wl_client *client,
+                                                   struct wl_resource *resource,
+                                                   struct wl_resource *timeline_resource,
+                                                   uint32_t point_hi, uint32_t point_lo);
+static void
+syncobj_timeline_handle_destroy (struct wl_client *client,
+                              struct wl_resource *resource);
+static void
+drm_syncobj_handle_destroy (struct wl_client *client,
+                            struct wl_resource *resource);
+static void
+drm_syncobj_handle_get_surface (struct wl_client *client,
+                                struct wl_resource *resource, uint32_t id,
+                                struct wl_resource *surface_resource);
+static void
+drm_syncobj_handle_import_timeline (struct wl_client *client,
+                                    struct wl_resource *resource,
+                                    uint32_t id, int drm_syncobj_fd);
+
+G_DEFINE_TYPE (MetaWaylandDrmSyncobjManager, meta_wayland_drm_syncobj_manager,
+               G_TYPE_OBJECT)
+
+G_DEFINE_TYPE (MetaWaylandSyncobjSurface, meta_wayland_syncobj_surface,
+               G_TYPE_OBJECT)
+
+G_DEFINE_TYPE (MetaWaylandSyncobjTimeline, meta_wayland_syncobj_timeline,
+               G_TYPE_OBJECT)
+
+static GQuark quark_syncobj_surface;
+
+static const struct wp_linux_drm_syncobj_surface_v1_interface syncobj_surface_implementation =
+{
+  syncobj_surface_handle_destroy,
+  syncobj_surface_handle_set_acquire_point,
+  syncobj_surface_handle_set_release_point,
+};
+
+static const struct wp_linux_drm_syncobj_timeline_v1_interface syncobj_timeline_implementation =
+{
+  syncobj_timeline_handle_destroy,
+};
+
+static const struct wp_linux_drm_syncobj_v1_interface drm_syncobj_implementation =
+{
+  drm_syncobj_handle_destroy,
+  drm_syncobj_handle_get_surface,
+  drm_syncobj_handle_import_timeline,
+};
+
+static void
+syncobj_timeline_handle_destroy (struct wl_client *client,
+                              struct wl_resource *resource)
+{
+  wl_resource_destroy (resource);
+}
+
+static void
+syncobj_surface_handle_destroy (struct wl_client *client,
+                             struct wl_resource *resource)
+{
+  wl_resource_destroy (resource);
+}
+
+static void
+syncobj_surface_handle_set_acquire_point (struct wl_client *client, struct wl_resource *resource,
+                                       struct wl_resource *timeline_resource, uint32_t point_hi,
+                                       uint32_t point_lo)
+{
+  MetaWaylandSyncobjSurface *syncobj_surface = wl_resource_get_user_data (resource);
+  MetaWaylandSurface *surface = syncobj_surface->surface;
+  MetaWaylandSyncobjTimeline *syncobj_timeline = wl_resource_get_user_data (timeline_resource);
+
+  if (!syncobj_surface)
+    {
+      wl_resource_post_error (resource, WP_LINUX_DRM_SYNCOBJ_SURFACE_V1_ERROR_NO_SURFACE,
+                              "Surface Sync object does not have surface attached");
+      return;
+    }
+
+  if (!syncobj_timeline)
+    {
+      meta_topic (META_DEBUG_RENDER, "Invalid sync timeline object");
+      return;
+    }
+
+  if (!surface->pending_state->drm_syncobj.acquire)
+    surface->pending_state->drm_syncobj.acquire = g_object_new (META_TYPE_WAYLAND_SYNC_POINT, NULL);
+
+  if (surface->pending_state->drm_syncobj.acquire->timeline)
+    g_object_unref (surface->pending_state->drm_syncobj.acquire->timeline);
+
+  surface->pending_state->drm_syncobj.acquire->timeline = syncobj_timeline;
+  surface->pending_state->drm_syncobj.acquire->sync_point = (uint64_t)point_hi << 32 | point_lo;
+}
+
+static void syncobj_surface_handle_set_release_point (struct wl_client *client,
+                                                   struct wl_resource *resource,
+                                                   struct wl_resource *timeline_resource,
+                                                   uint32_t point_hi, uint32_t point_lo)
+{
+  MetaWaylandSyncobjSurface *syncobj_surface = wl_resource_get_user_data (resource);
+  MetaWaylandSurface *surface = syncobj_surface->surface;
+  MetaWaylandSyncobjTimeline *syncobj_timeline = wl_resource_get_user_data (timeline_resource);
+
+  if (!syncobj_surface)
+    {
+      wl_resource_post_error (resource, WP_LINUX_DRM_SYNCOBJ_SURFACE_V1_ERROR_NO_SURFACE,
+                              "Surface Sync object does not have surface attached");
+      return;
+    }
+
+  if (!syncobj_timeline)
+    {
+      meta_topic (META_DEBUG_RENDER, "Invalid sync timeline object");
+      return;
+    }
+
+  if (!surface->pending_state->drm_syncobj.acquire)
+    surface->pending_state->drm_syncobj.acquire = g_object_new (META_TYPE_WAYLAND_SYNC_POINT, NULL);
+
+  if (surface->pending_state->drm_syncobj.release->timeline)
+    {
+      g_object_unref (surface->pending_state->drm_syncobj.release->timeline);
+    }
+
+  surface->pending_state->drm_syncobj.release->timeline = syncobj_timeline;
+  surface->pending_state->drm_syncobj.release->sync_point = (uint64_t)point_hi << 32 | point_lo;
+}
+
+static void
+drm_syncobj_handle_destroy (struct wl_client *client,
+                            struct wl_resource *resource)
+{
+  wl_resource_destroy (resource);
+}
+
+static void
+syncobj_surface_surface_destroyed_cb (gpointer user_data)
+{
+  MetaWaylandSyncobjSurface *surface_feedback = user_data;
+
+  g_object_unref (surface_feedback);
+}
+
+static void
+syncobj_surface_destructor (struct wl_resource *resource)
+{
+  MetaWaylandSyncobjSurface *syncobj_surface = wl_resource_get_user_data (resource);
+
+  if (!syncobj_surface)
+    return;
+
+  g_object_set_qdata (G_OBJECT (syncobj_surface->surface),
+                      quark_syncobj_surface, NULL);
+}
+
+static void
+drm_syncobj_handle_get_surface (struct wl_client *client,
+                                struct wl_resource *resource, uint32_t id,
+                                struct wl_resource *surface_resource)
+{
+  MetaWaylandSurface *surface = wl_resource_get_user_data (surface_resource);
+  MetaWaylandSyncobjSurface *syncobj_surface = g_object_get_qdata (G_OBJECT (surface),
+                                                             quark_syncobj_surface);
+  struct wl_resource *sync_resource;
+
+  if (syncobj_surface)
+    return;
+
+  syncobj_surface = g_object_new (META_TYPE_WAYLAND_SYNCOBJ_SURFACE, NULL);
+  syncobj_surface->surface = surface;
+  g_object_set_qdata_full (G_OBJECT (surface),
+                           quark_syncobj_surface,
+                           syncobj_surface,
+                           syncobj_surface_surface_destroyed_cb);
+
+  sync_resource =
+    wl_resource_create (client,
+                        &wp_linux_drm_syncobj_surface_v1_interface,
+                        wl_resource_get_version (resource),
+                        id);
+  if (sync_resource == NULL)
+    {
+      wl_resource_post_no_memory (resource);
+      g_object_unref (syncobj_surface);
+      return;
+    }
+
+  wl_resource_set_implementation (sync_resource,
+                                  &syncobj_surface_implementation,
+                                  syncobj_surface,
+                                  syncobj_surface_destructor);
+  syncobj_surface->resource = sync_resource;
+}
+
+static void
+syncobj_timeline_handle_resource_destroy (struct wl_resource *resource)
+{
+}
+
+static void
+drm_syncobj_handle_import_timeline (struct wl_client *client,
+                                    struct wl_resource *resource,
+                                    uint32_t id, int drm_syncobj_fd)
+{
+  MetaWaylandDrmSyncobjManager *drm_syncobj = wl_resource_get_user_data (resource);
+  GError *error = NULL;
+  MetaDrmTimeline *drm_timeline = meta_drm_timeline_import_syncobj (drm_syncobj->drm,
+                                                                    drm_syncobj_fd,
+                                                                    &error);
+  MetaWaylandSyncobjTimeline *syncobj_timeline;
+  struct wl_resource *timeline_resource;
+
+  close(drm_syncobj_fd);
+  if (!drm_timeline)
+    {
+      wl_resource_post_error (resource, WP_LINUX_DRM_SYNCOBJ_V1_ERROR_INVALID_TIMELINE,
+                              "Failed to import DRM syncobj: %s",
+                              error ? error->message : "unknown error");
+      return;
+    }
+
+  syncobj_timeline = g_object_new (META_TYPE_WAYLAND_SYNCOBJ_TIMELINE, NULL);
+
+  timeline_resource = wl_resource_create (client, &wp_linux_drm_syncobj_timeline_v1_interface,
+                                          wl_resource_get_version (resource), id);
+  if (timeline_resource == NULL)
+    {
+      wl_resource_post_no_memory (resource);
+      g_object_unref (drm_timeline);
+      g_object_unref (syncobj_timeline);
+      return;
+    }
+
+  wl_resource_set_implementation(timeline_resource,
+      &syncobj_timeline_implementation, syncobj_timeline, syncobj_timeline_handle_resource_destroy);
+
+  syncobj_timeline->resource = timeline_resource;
+  syncobj_timeline->drm_timeline = drm_timeline;
+}
+
+static void
+meta_wayland_syncobj_timeline_finalize (GObject *object)
+{
+  MetaWaylandSyncobjTimeline *syncobj_timeline =
+    META_WAYLAND_SYNCOBJ_TIMELINE (object);
+
+  g_object_unref (syncobj_timeline->drm_timeline);
+
+  G_OBJECT_CLASS (meta_wayland_syncobj_timeline_parent_class)->finalize (object);
+}
+
+static void
+meta_wayland_syncobj_timeline_class_init (MetaWaylandSyncobjTimelineClass *klass)
+{
+  GObjectClass *object_class = G_OBJECT_CLASS (klass);
+
+  object_class->finalize = meta_wayland_syncobj_timeline_finalize;
+}
+
+static void
+meta_wayland_syncobj_timeline_init (MetaWaylandSyncobjTimeline *syncobj_timeline)
+{
+  syncobj_timeline->resource = NULL;
+  syncobj_timeline->drm_timeline = NULL;
+}
+
+static void
+meta_wayland_syncobj_surface_finalize (GObject *object)
+{
+  G_OBJECT_CLASS (meta_wayland_syncobj_surface_parent_class)->finalize (object);
+}
+
+static void
+meta_wayland_syncobj_surface_class_init (MetaWaylandSyncobjSurfaceClass *klass)
+{
+  GObjectClass *object_class = G_OBJECT_CLASS (klass);
+
+  object_class->finalize = meta_wayland_syncobj_surface_finalize;
+}
+
+static void
+meta_wayland_syncobj_surface_init (MetaWaylandSyncobjSurface *syncobj_surface)
+{
+  syncobj_surface->resource = NULL;
+  syncobj_surface->surface = NULL;
+}
+
+static void
+meta_wayland_drm_syncobj_manager_finalize (GObject *object)
+{
+  MetaWaylandDrmSyncobjManager *drm_syncobj =
+    META_WAYLAND_DRM_SYNCOBJ_MANAGER (object);
+
+  close(drm_syncobj->drm);
+
+  G_OBJECT_CLASS (meta_wayland_drm_syncobj_manager_parent_class)->finalize (object);
+}
+
+static void
+meta_wayland_drm_syncobj_manager_class_init (MetaWaylandDrmSyncobjManagerClass *klass)
+{
+  GObjectClass *object_class = G_OBJECT_CLASS (klass);
+
+  object_class->finalize = meta_wayland_drm_syncobj_manager_finalize;
+}
+
+static void
+meta_wayland_drm_syncobj_manager_init (MetaWaylandDrmSyncobjManager *drm_syncobj)
+{
+  drm_syncobj->drm = -1;
+}
+
+static void
+drm_syncobj_bind (struct wl_client *client,
+                  void             *user_data,
+                  uint32_t          version,
+                  uint32_t          id)
+{
+  MetaWaylandDrmSyncobjManager *drm_syncobj_manager = user_data;
+  struct wl_resource *resource;
+
+  resource = wl_resource_create (client, &wp_linux_drm_syncobj_v1_interface,
+                                 version, id);
+  wl_resource_set_implementation (resource, &drm_syncobj_implementation,
+                                  drm_syncobj_manager, NULL);
+}
+
+void
+meta_wayland_drm_syncobj_init (MetaWaylandCompositor *compositor)
+{
+#ifdef HAVE_NATIVE_BACKEND
+  MetaContext *context =
+    meta_wayland_compositor_get_context (compositor);
+  MetaBackend *backend = meta_context_get_backend (context);
+  MetaRenderer *renderer = meta_backend_get_renderer (backend);
+  MetaRendererNative *renderer_native = META_RENDERER_NATIVE (renderer);
+  MetaDeviceFile *device_file = meta_renderer_native_get_primary_device_file (renderer_native);
+  g_autoptr (MetaWaylandDrmSyncobjManager) drm_syncobj_manager;
+
+  if (!device_file)
+    {
+      meta_topic (META_DEBUG_RENDER, "Failed to get device file");
+      return;
+    }
+
+  drm_syncobj_manager = g_object_new (META_TYPE_WAYLAND_DRM_SYNCOBJ_MANAGER, NULL);
+  drm_syncobj_manager->drm = dup (meta_device_file_get_fd (device_file));
+
+  if (!wl_global_create (compositor->wayland_display,
+                         &wp_linux_drm_syncobj_v1_interface,
+                         1,
+                         drm_syncobj_manager,
+                         drm_syncobj_bind))
+    {
+      g_error ("Failed to create wp_linux_drm_syncobjhronization_v1_interface global");
+    }
+#endif
+}
diff --git a/src/wayland/meta-wayland-linux-drm-syncobj.h b/src/wayland/meta-wayland-linux-drm-syncobj.h
new file mode 100644
index 000000000..df21f1f02
--- /dev/null
+++ b/src/wayland/meta-wayland-linux-drm-syncobj.h
@@ -0,0 +1,62 @@
+/* -*- mode: C; c-file-style: "gnu"; indent-tabs-mode: nil; -*- */
+
+/*
+ * Copyright (C) 2023 NVIDIA Corporation.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of the
+ * License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, see <http://www.gnu.org/licenses/>.
+ *
+ * Written by:
+ *     Austin Shafer <ashafer@nvidia.com>
+ */
+
+#pragma once
+
+#include <glib.h>
+
+#include "wayland/meta-wayland-types.h"
+#include "wayland/meta-drm-timeline.h"
+
+#define META_TYPE_WAYLAND_DRM_SYNCOBJ_MANAGER (meta_wayland_drm_syncobj_manager_get_type ())
+G_DECLARE_FINAL_TYPE (MetaWaylandDrmSyncobjManager, meta_wayland_drm_syncobj_manager,
+                      META, WAYLAND_DRM_SYNCOBJ_MANAGER, GObject)
+
+#define META_TYPE_WAYLAND_SYNCOBJ_SURFACE (meta_wayland_syncobj_surface_get_type ())
+G_DECLARE_FINAL_TYPE (MetaWaylandSyncobjSurface, meta_wayland_syncobj_surface,
+                      META, WAYLAND_SYNCOBJ_SURFACE, GObject)
+
+#define META_TYPE_WAYLAND_SYNCOBJ_TIMELINE (meta_wayland_syncobj_timeline_get_type ())
+G_DECLARE_FINAL_TYPE (MetaWaylandSyncobjTimeline, meta_wayland_syncobj_timeline,
+                      META, WAYLAND_SYNCOBJ_TIMELINE, GObject)
+
+typedef struct _MetaWaylandSyncobjSurface MetaWaylandSyncobjSurface;
+
+typedef struct _MetaWaylandSyncobjTimeline
+{
+  GObject parent;
+
+  struct wl_resource *resource;
+  MetaDrmTimeline *drm_timeline;
+} MetaWaylandSyncobjTimeline;
+
+typedef void (*MetaWaylandDrmSyncobjSourceDispatch) (MetaWaylandSurface *surface,
+                                                     gpointer            user_data);
+
+void meta_wayland_drm_syncobj_init (MetaWaylandCompositor *compositor);
+
+GSource *
+meta_wayland_drm_syncobj_create_source (MetaWaylandSurface                    *surface,
+                                        MetaWaylandSyncobjTimeline               *timeline,
+                                        uint64_t                               sync_point,
+                                        MetaWaylandDrmSyncobjSourceDispatch  dispatch,
+                                        gpointer                               user_data);
diff --git a/src/wayland/meta-wayland-surface.c b/src/wayland/meta-wayland-surface.c
index d42f31828..7d99cc8c5 100644
--- a/src/wayland/meta-wayland-surface.c
+++ b/src/wayland/meta-wayland-surface.c
@@ -99,6 +99,8 @@ G_DEFINE_TYPE (MetaWaylandSurfaceState,
                meta_wayland_surface_state,
                G_TYPE_OBJECT)
 
+G_DEFINE_TYPE (MetaWaylandSyncPoint, meta_wayland_sync_point, G_TYPE_OBJECT);
+
 enum
 {
   SURFACE_DESTROY,
@@ -421,6 +423,9 @@ meta_wayland_surface_state_set_default (MetaWaylandSurfaceState *state)
   wl_list_init (&state->presentation_feedback_list);
 
   state->xdg_popup_reposition_token = 0;
+
+  state->drm_syncobj.acquire = g_object_new (META_TYPE_WAYLAND_SYNC_POINT, NULL);
+  state->drm_syncobj.release = g_object_new (META_TYPE_WAYLAND_SYNC_POINT, NULL);
 }
 
 static void
@@ -447,6 +452,8 @@ meta_wayland_surface_state_clear (MetaWaylandSurfaceState *state)
   g_clear_pointer (&state->input_region, cairo_region_destroy);
   g_clear_pointer (&state->opaque_region, cairo_region_destroy);
   g_clear_pointer (&state->xdg_positioner, g_free);
+  g_clear_object (&state->drm_syncobj.acquire);
+  g_clear_object (&state->drm_syncobj.release);
 
   if (state->buffer_destroy_handler_id)
     {
@@ -605,6 +612,20 @@ meta_wayland_surface_state_merge_into (MetaWaylandSurfaceState *from,
       to->xdg_positioner = g_steal_pointer (&from->xdg_positioner);
       to->xdg_popup_reposition_token = from->xdg_popup_reposition_token;
     }
+
+  if (from->drm_syncobj.acquire)
+    {
+      g_object_unref (to->drm_syncobj.acquire);
+      to->drm_syncobj.acquire = from->drm_syncobj.acquire;
+      g_clear_object (&from->drm_syncobj.acquire);
+    }
+
+  if (from->drm_syncobj.release)
+    {
+      g_object_unref (to->drm_syncobj.release);
+      to->drm_syncobj.release = from->drm_syncobj.release;
+      g_clear_object (&from->drm_syncobj.release);
+    }
 }
 
 static void
@@ -639,6 +660,30 @@ meta_wayland_surface_state_class_init (MetaWaylandSurfaceStateClass *klass)
                   G_TYPE_NONE, 0);
 }
 
+static void
+meta_wayland_sync_point_finalize (GObject *object)
+{
+  MetaWaylandSyncPoint *sync = META_WAYLAND_SYNC_POINT (object);
+
+  g_object_unref (sync->timeline);
+
+  G_OBJECT_CLASS (meta_wayland_sync_point_parent_class)->finalize (object);
+}
+
+static void
+meta_wayland_sync_point_init (MetaWaylandSyncPoint *sync)
+{
+}
+
+static void
+meta_wayland_sync_point_class_init (MetaWaylandSyncPointClass *klass)
+{
+  GObjectClass *object_class = G_OBJECT_CLASS (klass);
+
+  object_class->finalize = meta_wayland_sync_point_finalize;
+}
+
+
 static void
 meta_wayland_surface_discard_presentation_feedback (MetaWaylandSurface *surface)
 {
@@ -924,6 +969,7 @@ meta_wayland_surface_commit (MetaWaylandSurface *surface)
   MetaWaylandBuffer *buffer = pending->buffer;
   MetaWaylandTransaction *transaction;
   MetaWaylandSurface *subsurface_surface;
+  MetaWaylandSyncPoint *release_point;
 
   COGL_TRACE_BEGIN_SCOPED (MetaWaylandSurfaceCommit,
                            "WaylandSurface (commit)");
@@ -953,6 +999,9 @@ meta_wayland_surface_commit (MetaWaylandSurface *surface)
 
       pending->texture = g_object_ref (surface->protocol_state.texture);
 
+      release_point = g_object_ref (surface->pending_state->drm_syncobj.release);
+      g_array_append_val (buffer->release_points, release_point);
+
       g_object_ref (buffer);
       meta_wayland_buffer_inc_use_count (buffer);
     }
diff --git a/src/wayland/meta-wayland-surface.h b/src/wayland/meta-wayland-surface.h
index 3e8db5a87..c5803f80c 100644
--- a/src/wayland/meta-wayland-surface.h
+++ b/src/wayland/meta-wayland-surface.h
@@ -46,6 +46,12 @@ G_DECLARE_FINAL_TYPE (MetaWaylandSurfaceState,
                       META, WAYLAND_SURFACE_STATE,
                       GObject)
 
+#define META_TYPE_WAYLAND_SYNC_POINT (meta_wayland_sync_point_get_type ())
+G_DECLARE_FINAL_TYPE (MetaWaylandSyncPoint,
+                      meta_wayland_sync_point,
+                      META, WAYLAND_SYNC_POINT,
+                      GObject)
+
 struct _MetaWaylandSurfaceRoleClass
 {
   GObjectClass parent_class;
@@ -73,6 +79,13 @@ struct _MetaWaylandSurfaceRoleClass
   MetaWindow * (*get_window) (MetaWaylandSurfaceRole *surface_role);
 };
 
+typedef struct _MetaWaylandSyncPoint {
+  GObject parent;
+
+  MetaWaylandSyncobjTimeline *timeline;
+  uint64_t sync_point;
+} MetaWaylandSyncPoint;
+
 struct _MetaWaylandSurfaceState
 {
   GObject parent;
@@ -134,6 +147,12 @@ struct _MetaWaylandSurfaceState
   /* xdg_popup */
   MetaWaylandXdgPositioner *xdg_positioner;
   uint32_t xdg_popup_reposition_token;
+
+  /* Explicit Synchronization */
+  struct {
+    MetaWaylandSyncPoint *acquire;
+    MetaWaylandSyncPoint *release;
+  } drm_syncobj;
 };
 
 struct _MetaWaylandDragDestFuncs
diff --git a/src/wayland/meta-wayland-types.h b/src/wayland/meta-wayland-types.h
index c14b340f4..c6f85508d 100644
--- a/src/wayland/meta-wayland-types.h
+++ b/src/wayland/meta-wayland-types.h
@@ -64,6 +64,9 @@ typedef struct _MetaWaylandActivation MetaWaylandActivation;
 
 typedef struct _MetaWaylandDmaBufManager MetaWaylandDmaBufManager;
 
+typedef struct _MetaWaylandDrmSyncobjManager MetaWaylandDrmSyncobjManager;
+typedef struct _MetaWaylandSyncobjTimeline MetaWaylandSyncobjTimeline;
+
 typedef struct _MetaWaylandXdgPositioner MetaWaylandXdgPositioner;
 
 typedef struct _MetaXWaylandManager MetaXWaylandManager;
diff --git a/src/wayland/meta-wayland.c b/src/wayland/meta-wayland.c
index a2bd7d2ab..a3569af53 100644
--- a/src/wayland/meta-wayland.c
+++ b/src/wayland/meta-wayland.c
@@ -50,6 +50,7 @@
 #include "wayland/meta-wayland-tablet-manager.h"
 #include "wayland/meta-wayland-transaction.h"
 #include "wayland/meta-wayland-xdg-foreign.h"
+#include "wayland/meta-wayland-linux-drm-syncobj.h"
 
 #ifdef HAVE_XWAYLAND
 #include "wayland/meta-wayland-x11-interop.h"
@@ -808,6 +809,7 @@ meta_wayland_compositor_new (MetaContext *context)
   meta_wayland_activation_init (compositor);
   meta_wayland_transaction_init (compositor);
   meta_wayland_idle_inhibit_init (compositor);
+  meta_wayland_drm_syncobj_init (compositor);
 
 #ifdef HAVE_WAYLAND_EGLSTREAM
   {
-- 
2.42.0


From 1e8db82ff57716397f93163b2c0f3821b3ee2f1d Mon Sep 17 00:00:00 2001
From: Austin Shafer <ashafer@badland.io>
Date: Tue, 12 Sep 2023 17:30:19 -0400
Subject: [PATCH 6/6] wayland-transaction: Check for explicit sync acquire
 fences

---
 src/wayland/meta-wayland-dma-buf.c           | 168 ----------
 src/wayland/meta-wayland-dma-buf.h           |  27 +-
 src/wayland/meta-wayland-linux-drm-syncobj.h |  10 -
 src/wayland/meta-wayland-transaction.c       | 312 +++++++++++++++++--
 src/wayland/meta-wayland-transaction.h       |   3 +
 5 files changed, 310 insertions(+), 210 deletions(-)

diff --git a/src/wayland/meta-wayland-dma-buf.c b/src/wayland/meta-wayland-dma-buf.c
index 8e9993898..a99d583e9 100644
--- a/src/wayland/meta-wayland-dma-buf.c
+++ b/src/wayland/meta-wayland-dma-buf.c
@@ -65,8 +65,6 @@
 
 #include "linux-dmabuf-unstable-v1-server-protocol.h"
 
-#define META_WAYLAND_DMA_BUF_MAX_FDS 4
-
 /* Compatible with zwp_linux_dmabuf_feedback_v1.tranche_flags */
 typedef enum _MetaWaylandDmaBufTrancheFlags
 {
@@ -123,22 +121,6 @@ struct _MetaWaylandDmaBufManager
   MetaWaylandDmaBufFeedback *default_feedback;
 };
 
-struct _MetaWaylandDmaBufBuffer
-{
-  GObject parent;
-
-  MetaWaylandDmaBufManager *manager;
-
-  int width;
-  int height;
-  uint32_t drm_format;
-  uint64_t drm_modifier;
-  bool is_y_inverted;
-  int fds[META_WAYLAND_DMA_BUF_MAX_FDS];
-  uint32_t offsets[META_WAYLAND_DMA_BUF_MAX_FDS];
-  uint32_t strides[META_WAYLAND_DMA_BUF_MAX_FDS];
-};
-
 G_DEFINE_TYPE (MetaWaylandDmaBufBuffer, meta_wayland_dma_buf_buffer, G_TYPE_OBJECT);
 
 G_DEFINE_TYPE (MetaWaylandDmaBufManager, meta_wayland_dma_buf_manager,
@@ -837,156 +819,6 @@ meta_wayland_dma_buf_from_buffer (MetaWaylandBuffer *buffer)
   return buffer->dma_buf.dma_buf;
 }
 
-typedef struct _MetaWaylandDmaBufSource
-{
-  GSource base;
-
-  MetaWaylandDmaBufSourceDispatch dispatch;
-  MetaWaylandBuffer *buffer;
-  MetaWaylandSurface *surface;
-  gpointer user_data;
-
-  gpointer fd_tags[META_WAYLAND_DMA_BUF_MAX_FDS];
-} MetaWaylandDmaBufSource;
-
-static gboolean
-meta_wayland_dma_buf_fd_readable (int fd)
-{
-  GPollFD poll_fd;
-
-  poll_fd.fd = fd;
-  poll_fd.events = G_IO_IN;
-  poll_fd.revents = 0;
-
-  if (!g_poll (&poll_fd, 1, 0))
-    return FALSE;
-
-  return (poll_fd.revents & (G_IO_IN | G_IO_NVAL)) != 0;
-}
-
-static gboolean
-meta_wayland_dma_buf_source_dispatch (GSource     *base,
-                                      GSourceFunc  callback,
-                                      gpointer     user_data)
-{
-  MetaWaylandDmaBufSource *source;
-  MetaWaylandDmaBufBuffer *dma_buf;
-  gboolean ready;
-  uint32_t i;
-
-  source = (MetaWaylandDmaBufSource *) base;
-  dma_buf = source->buffer->dma_buf.dma_buf;
-  ready = TRUE;
-
-  for (i = 0; i < META_WAYLAND_DMA_BUF_MAX_FDS; i++)
-    {
-      gpointer fd_tag = source->fd_tags[i];
-
-      if (!fd_tag)
-        continue;
-
-      if (!meta_wayland_dma_buf_fd_readable (dma_buf->fds[i]))
-        {
-          ready = FALSE;
-          continue;
-        }
-
-      g_source_remove_unix_fd (&source->base, fd_tag);
-      source->fd_tags[i] = NULL;
-    }
-
-  if (!ready)
-    return G_SOURCE_CONTINUE;
-
-  source->dispatch (source->buffer, source->user_data);
-
-  return G_SOURCE_REMOVE;
-}
-
-static void
-meta_wayland_dma_buf_source_finalize (GSource *base)
-{
-  MetaWaylandDmaBufSource *source;
-  uint32_t i;
-
-  source = (MetaWaylandDmaBufSource *) base;
-
-  for (i = 0; i < META_WAYLAND_DMA_BUF_MAX_FDS; i++)
-    {
-      gpointer fd_tag = source->fd_tags[i];
-
-      if (fd_tag)
-        {
-          g_source_remove_unix_fd (&source->base, fd_tag);
-          source->fd_tags[i] = NULL;
-        }
-    }
-
-  g_clear_object (&source->buffer);
-}
-
-static GSourceFuncs meta_wayland_dma_buf_source_funcs = {
-  .dispatch = meta_wayland_dma_buf_source_dispatch,
-  .finalize = meta_wayland_dma_buf_source_finalize
-};
-
-/**
- * meta_wayland_dma_buf_create_source:
- * @buffer: A #MetaWaylandBuffer object
- * @dispatch: Callback
- * @user_data: User data for the callback
- *
- * Creates a GSource which will call the specified dispatch callback when all
- * dma-buf file descriptors for the buffer have become readable.
- *
- * Returns: The new GSource (or
- * %NULL if there are no dma-buf file descriptors, or they were all readable
- * already)
- */
-GSource *
-meta_wayland_dma_buf_create_source (MetaWaylandBuffer               *buffer,
-                                    MetaWaylandSurface              *surface,
-                                    MetaWaylandDmaBufSourceDispatch  dispatch,
-                                    gpointer                         user_data)
-{
-  MetaWaylandDmaBufBuffer *dma_buf;
-  MetaWaylandDmaBufSource *source = NULL;
-  uint32_t i;
-
-  dma_buf = buffer->dma_buf.dma_buf;
-  if (!dma_buf)
-    return NULL;
-
-  for (i = 0; i < META_WAYLAND_DMA_BUF_MAX_FDS; i++)
-    {
-      int fd = dma_buf->fds[i];
-
-      if (fd < 0)
-        break;
-
-      if (meta_wayland_dma_buf_fd_readable (fd))
-        continue;
-
-      if (!source)
-        {
-          source =
-            (MetaWaylandDmaBufSource *) g_source_new (&meta_wayland_dma_buf_source_funcs,
-                                                      sizeof (*source));
-          source->buffer = g_object_ref (buffer);
-          source->dispatch = dispatch;
-          source->surface = surface;
-          source->user_data = user_data;
-        }
-
-      source->fd_tags[i] = g_source_add_unix_fd (&source->base, fd, G_IO_IN);
-    }
-
-  if (!source)
-    return NULL;
-
-  return &source->base;
-}
-
 static void
 buffer_params_create_common (struct wl_client   *client,
                              struct wl_resource *params_resource,
diff --git a/src/wayland/meta-wayland-dma-buf.h b/src/wayland/meta-wayland-dma-buf.h
index 154937418..1bce4894c 100644
--- a/src/wayland/meta-wayland-dma-buf.h
+++ b/src/wayland/meta-wayland-dma-buf.h
@@ -31,6 +31,8 @@
 #include "meta/meta-multi-texture.h"
 #include "wayland/meta-wayland-types.h"
 
+#define META_WAYLAND_DMA_BUF_MAX_FDS 4
+
 #define META_TYPE_WAYLAND_DMA_BUF_BUFFER (meta_wayland_dma_buf_buffer_get_type ())
 G_DECLARE_FINAL_TYPE (MetaWaylandDmaBufBuffer, meta_wayland_dma_buf_buffer,
                       META, WAYLAND_DMA_BUF_BUFFER, GObject);
@@ -39,7 +41,21 @@ G_DECLARE_FINAL_TYPE (MetaWaylandDmaBufBuffer, meta_wayland_dma_buf_buffer,
 G_DECLARE_FINAL_TYPE (MetaWaylandDmaBufManager, meta_wayland_dma_buf_manager,
                       META, WAYLAND_DMA_BUF_MANAGER, GObject)
 
-typedef struct _MetaWaylandDmaBufBuffer MetaWaylandDmaBufBuffer;
+typedef struct _MetaWaylandDmaBufBuffer
+{
+  GObject parent;
+
+  MetaWaylandDmaBufManager *manager;
+
+  int width;
+  int height;
+  uint32_t drm_format;
+  uint64_t drm_modifier;
+  bool is_y_inverted;
+  int fds[META_WAYLAND_DMA_BUF_MAX_FDS];
+  uint32_t offsets[META_WAYLAND_DMA_BUF_MAX_FDS];
+  uint32_t strides[META_WAYLAND_DMA_BUF_MAX_FDS];
+} MetaWaylandDmaBufBuffer;
 
 MetaWaylandDmaBufManager * meta_wayland_dma_buf_manager_new (MetaWaylandCompositor  *compositor,
                                                              GError                **error);
@@ -55,15 +71,6 @@ meta_wayland_dma_buf_fds_for_wayland_buffer (MetaWaylandBuffer *buffer);
 MetaWaylandDmaBufBuffer *
 meta_wayland_dma_buf_from_buffer (MetaWaylandBuffer *buffer);
 
-typedef void (*MetaWaylandDmaBufSourceDispatch) (MetaWaylandBuffer *buffer,
-                                                 gpointer           user_data);
-
-GSource *
-meta_wayland_dma_buf_create_source (MetaWaylandBuffer               *buffer,
-                                    MetaWaylandSurface              *surface,
-                                    MetaWaylandDmaBufSourceDispatch  dispatch,
-                                    gpointer                         user_data);
-
 CoglScanout *
 meta_wayland_dma_buf_try_acquire_scanout (MetaWaylandDmaBufBuffer *dma_buf,
                                           CoglOnscreen            *onscreen);
diff --git a/src/wayland/meta-wayland-linux-drm-syncobj.h b/src/wayland/meta-wayland-linux-drm-syncobj.h
index df21f1f02..7c18f0f3c 100644
--- a/src/wayland/meta-wayland-linux-drm-syncobj.h
+++ b/src/wayland/meta-wayland-linux-drm-syncobj.h
@@ -49,14 +49,4 @@ typedef struct _MetaWaylandSyncobjTimeline
   MetaDrmTimeline *drm_timeline;
 } MetaWaylandSyncobjTimeline;
 
-typedef void (*MetaWaylandDrmSyncobjSourceDispatch) (MetaWaylandSurface *surface,
-                                                     gpointer            user_data);
-
 void meta_wayland_drm_syncobj_init (MetaWaylandCompositor *compositor);
-
-GSource *
-meta_wayland_drm_syncobj_create_source (MetaWaylandSurface                    *surface,
-                                        MetaWaylandSyncobjTimeline               *timeline,
-                                        uint64_t                               sync_point,
-                                        MetaWaylandDrmSyncobjSourceDispatch  dispatch,
-                                        gpointer                               user_data);
diff --git a/src/wayland/meta-wayland-transaction.c b/src/wayland/meta-wayland-transaction.c
index 0568ba3e0..ac864ac7c 100644
--- a/src/wayland/meta-wayland-transaction.c
+++ b/src/wayland/meta-wayland-transaction.c
@@ -26,9 +26,16 @@
 #include "wayland/meta-wayland.h"
 #include "wayland/meta-wayland-buffer.h"
 #include "wayland/meta-wayland-dma-buf.h"
+#include "wayland/meta-wayland-linux-drm-syncobj.h"
 
 #define META_WAYLAND_TRANSACTION_NONE ((void *)(uintptr_t) G_MAXSIZE)
 
+typedef enum _MetaDrmSourceType
+{
+  DMA_BUF_SOURCE,
+  DRM_SYNCOBJ_SOURCE,
+} MetaDrmSourceType;
+
 struct _MetaWaylandTransaction
 {
   GList node;
@@ -59,6 +66,131 @@ struct _MetaWaylandTransactionEntry
   int y;
 };
 
+typedef struct _MetaWaylandDrmSource
+{
+  GSource base;
+
+  MetaDrmSourceType type;
+  MetaWaylandDrmSourceDispatch dispatch;
+  MetaWaylandBuffer *buffer;
+  MetaWaylandSurface *surface;
+  gpointer user_data;
+
+  /* -- dmabuf source fields -- */
+  gpointer fd_tags[META_WAYLAND_DMA_BUF_MAX_FDS];
+
+  /* -- explicit sync fields -- */
+  int sync_fd;
+  gpointer sync_fd_tag;
+} MetaWaylandDrmSource;
+
+static gboolean
+meta_wayland_drm_fd_readable (int fd)
+{
+  GPollFD poll_fd;
+
+  poll_fd.fd = fd;
+  poll_fd.events = G_IO_IN;
+  poll_fd.revents = 0;
+
+  if (!g_poll (&poll_fd, 1, 0))
+    return FALSE;
+
+  return (poll_fd.revents & (G_IO_IN | G_IO_NVAL)) != 0;
+}
+
+static gboolean
+meta_wayland_drm_source_dispatch (GSource     *base,
+                                      GSourceFunc  callback,
+                                      gpointer     user_data)
+{
+  MetaWaylandDrmSource *source;
+  MetaWaylandDmaBufBuffer *dma_buf;
+  gboolean ready;
+  uint32_t i;
+
+  source = (MetaWaylandDrmSource *) base;
+
+  if (source->type == DMA_BUF_SOURCE)
+    {
+      dma_buf = source->buffer->dma_buf.dma_buf;
+      ready = TRUE;
+
+      for (i = 0; i < META_WAYLAND_DMA_BUF_MAX_FDS; i++)
+        {
+          gpointer fd_tag = source->fd_tags[i];
+
+          if (!fd_tag)
+            continue;
+
+          if (!meta_wayland_drm_fd_readable (dma_buf->fds[i]))
+            {
+              ready = FALSE;
+              continue;
+            }
+
+          g_source_remove_unix_fd (&source->base, fd_tag);
+          source->fd_tags[i] = NULL;
+        }
+
+      if (!ready)
+        return G_SOURCE_CONTINUE;
+    }
+
+  if (source->type == DRM_SYNCOBJ_SOURCE)
+    {
+      if (!source->sync_fd_tag)
+        return G_SOURCE_CONTINUE;
+
+      if (!meta_wayland_drm_fd_readable (source->sync_fd))
+        {
+          return G_SOURCE_CONTINUE;
+        }
+
+      g_source_remove_unix_fd (&source->base, source->sync_fd_tag);
+      close (source->sync_fd);
+      source->sync_fd_tag = NULL;
+    }
+
+  source->dispatch (source->buffer, source->user_data);
+
+  return G_SOURCE_REMOVE;
+}
+
+static void
+meta_wayland_drm_source_finalize (GSource *base)
+{
+  MetaWaylandDrmSource *source;
+  uint32_t i;
+
+  source = (MetaWaylandDrmSource *) base;
+
+  for (i = 0; i < META_WAYLAND_DMA_BUF_MAX_FDS; i++)
+    {
+      gpointer fd_tag = source->fd_tags[i];
+
+      if (fd_tag)
+        {
+          g_source_remove_unix_fd (&source->base, fd_tag);
+          source->fd_tags[i] = NULL;
+        }
+    }
+
+  if (source->sync_fd_tag)
+    {
+      g_source_remove_unix_fd (&source->base, source->sync_fd_tag);
+      close (source->sync_fd);
+      source->sync_fd_tag = NULL;
+    }
+
+  g_clear_object (&source->buffer);
+}
+
+static GSourceFuncs meta_wayland_drm_source_funcs = {
+  .dispatch = meta_wayland_drm_source_dispatch,
+  .finalize = meta_wayland_drm_source_finalize
+};
+
 static MetaWaylandTransactionEntry *
 meta_wayland_transaction_get_entry (MetaWaylandTransaction *transaction,
                                     MetaWaylandSurface     *surface)
@@ -275,8 +407,8 @@ meta_wayland_transaction_maybe_apply (MetaWaylandTransaction *transaction)
 }
 
 static void
-meta_wayland_transaction_dma_buf_dispatch (MetaWaylandBuffer *buffer,
-                                           gpointer           user_data)
+meta_wayland_transaction_drm_dispatch (MetaWaylandBuffer *buffer,
+                                       gpointer           user_data)
 {
   MetaWaylandTransaction *transaction = user_data;
 
@@ -287,6 +419,100 @@ meta_wayland_transaction_dma_buf_dispatch (MetaWaylandBuffer *buffer,
   meta_wayland_transaction_maybe_apply (transaction);
 }
 
+static GSource *
+meta_wayland_dma_buf_create_source (MetaWaylandBuffer               *buffer,
+                                    MetaWaylandSurface              *surface,
+                                    MetaWaylandDrmSourceDispatch     dispatch,
+                                    gpointer                         user_data)
+{
+  MetaWaylandDmaBufBuffer *dma_buf;
+  MetaWaylandDrmSource *source = NULL;
+  uint32_t i;
+
+  dma_buf = buffer->dma_buf.dma_buf;
+  if (!dma_buf)
+    return NULL;
+
+  for (i = 0; i < META_WAYLAND_DMA_BUF_MAX_FDS; i++)
+    {
+      int fd = dma_buf->fds[i];
+
+      if (fd < 0)
+        break;
+
+      if (meta_wayland_drm_fd_readable (fd))
+        continue;
+
+      if (!source)
+        {
+          source =
+            (MetaWaylandDrmSource *) g_source_new (&meta_wayland_drm_source_funcs,
+                                                      sizeof (*source));
+          source->buffer = g_object_ref (buffer);
+          source->type = DMA_BUF_SOURCE;
+          source->dispatch = dispatch;
+          source->surface = surface;
+          source->user_data = user_data;
+        }
+
+      source->fd_tags[i] = g_source_add_unix_fd (&source->base, fd, G_IO_IN);
+    }
+
+  if (!source)
+    return NULL;
+
+  return &source->base;
+}
+
+static GSource *
+meta_wayland_drm_syncobj_create_source (MetaWaylandBuffer                     *buffer,
+                                        MetaWaylandSurface                    *surface,
+                                        MetaWaylandSyncobjTimeline            *timeline,
+                                        uint64_t                               sync_point,
+                                        MetaWaylandDrmSourceDispatch           dispatch,
+                                        gpointer                               user_data)
+{
+  MetaWaylandDrmSource *source = NULL;
+  int sync_fd;
+  GError *error = NULL;
+
+  if (!timeline)
+    return NULL;
+
+  sync_fd = meta_drm_timeline_get_eventfd (timeline->drm_timeline, sync_point, &error);
+  if (sync_fd < 0)
+    {
+      g_warning ("Failed to get sync fd: %s", error ? error->message : "Unknown error");
+      return NULL;
+    }
+
+  if (meta_wayland_drm_fd_readable (sync_fd))
+    {
+      close(sync_fd);
+      return NULL;
+    }
+
+  source =
+    (MetaWaylandDrmSource *) g_source_new (&meta_wayland_drm_source_funcs,
+                                       sizeof (*source));
+  if (!source)
+    {
+      close(sync_fd);
+      return NULL;
+    }
+
+  source->buffer = g_object_ref (buffer);
+  source->surface = surface;
+  source->type = DRM_SYNCOBJ_SOURCE;
+  source->dispatch = dispatch;
+  source->user_data = user_data;
+  source->sync_fd = sync_fd;
+  source->sync_fd_tag = g_source_add_unix_fd (&source->base, sync_fd, G_IO_IN);
+
+  return &source->base;
+}
+
+
 static gboolean
 meta_wayland_transaction_add_dma_buf_source (MetaWaylandTransaction *transaction,
                                              MetaWaylandBuffer      *buffer,
@@ -300,7 +526,7 @@ meta_wayland_transaction_add_dma_buf_source (MetaWaylandTransaction *transaction
 
   source = meta_wayland_dma_buf_create_source (buffer,
                                                surface,
-                                               meta_wayland_transaction_dma_buf_dispatch,
+                                               meta_wayland_transaction_drm_dispatch,
                                                transaction);
   if (!source)
     return FALSE;
@@ -319,6 +545,63 @@ meta_wayland_transaction_add_dma_buf_source (MetaWaylandTransaction *transaction
   return TRUE;
 }
 
+static gboolean
+meta_wayland_transaction_add_drm_syncobj_source (MetaWaylandTransaction *transaction,
+                                                 MetaWaylandBuffer      *buffer,
+                                                 MetaWaylandSurface     *surface)
+{
+  GSource *source;
+  MetaWaylandTransactionEntry *entry;
+
+  if (transaction->buf_sources &&
+      g_hash_table_contains (transaction->buf_sources, surface))
+    return FALSE;
+
+  entry = meta_wayland_transaction_get_entry (transaction, surface);
+  if (!entry)
+    return FALSE;
+
+  source =
+    meta_wayland_drm_syncobj_create_source (buffer,
+                                            surface,
+                                            entry->state->drm_syncobj.acquire->timeline,
+                                            entry->state->drm_syncobj.acquire->sync_point,
+                                            meta_wayland_transaction_drm_dispatch,
+                                            transaction);
+  if (!source)
+    return FALSE;
+
+  if (!transaction->buf_sources)
+    {
+      transaction->buf_sources =
+        g_hash_table_new_full (NULL, NULL, NULL,
+                               (GDestroyNotify) g_source_destroy);
+    }
+
+  g_hash_table_insert (transaction->buf_sources, surface, source);
+  g_source_attach (source, NULL);
+  g_source_unref (source);
+
+  return TRUE;
+}
+
+static void
+meta_wayland_transaction_add_placement_surfaces (MetaWaylandTransaction  *transaction,
+                                                 MetaWaylandSurfaceState *state)
+{
+  GSList *l;
+
+  for (l = state->subsurface_placement_ops; l; l = l->next)
+    {
+      MetaWaylandSubsurfacePlacementOp *op = l->data;
+
+      meta_wayland_transaction_ensure_entry (transaction, op->surface);
+
+      if (op->sibling)
+        meta_wayland_transaction_ensure_entry (transaction, op->sibling);
+    }
+}
+
 void
 meta_wayland_transaction_commit (MetaWaylandTransaction *transaction)
 {
@@ -337,8 +620,10 @@ meta_wayland_transaction_commit (MetaWaylandTransaction *transaction)
         {
           MetaWaylandBuffer *buffer = entry->state->buffer;
 
-          if (buffer &&
-              meta_wayland_transaction_add_dma_buf_source (transaction, buffer, surface))
+          if ((entry->state->drm_syncobj.acquire &&
+               meta_wayland_transaction_add_drm_syncobj_source (transaction, buffer, surface))
+               || (buffer &&
+                   meta_wayland_transaction_add_dma_buf_source (transaction, buffer, surface)))
             maybe_apply = FALSE;
         }
     }
@@ -404,23 +689,6 @@ meta_wayland_transaction_entry_free (MetaWaylandTransactionEntry *entry)
   g_free (entry);
 }
 
-static void
-meta_wayland_transaction_add_placement_surfaces (MetaWaylandTransaction  *transaction,
-                                                 MetaWaylandSurfaceState *state)
-{
-  GSList *l;
-
-  for (l = state->subsurface_placement_ops; l; l = l->next)
-    {
-      MetaWaylandSubsurfacePlacementOp *op = l->data;
-
-      meta_wayland_transaction_ensure_entry (transaction, op->surface);
-
-      if (op->sibling)
-        meta_wayland_transaction_ensure_entry (transaction, op->sibling);
-    }
-}
-
 static void
 meta_wayland_transaction_add_entry (MetaWaylandTransaction      *transaction,
                                     MetaWaylandSurface          *surface,
diff --git a/src/wayland/meta-wayland-transaction.h b/src/wayland/meta-wayland-transaction.h
index 6674d2c2c..28a5692e1 100644
--- a/src/wayland/meta-wayland-transaction.h
+++ b/src/wayland/meta-wayland-transaction.h
@@ -52,3 +52,6 @@ void meta_wayland_transaction_free (MetaWaylandTransaction *transaction);
 void meta_wayland_transaction_finalize (MetaWaylandCompositor *compositor);
 
 void meta_wayland_transaction_init (MetaWaylandCompositor *compositor);
+
+typedef void (*MetaWaylandDrmSourceDispatch) (MetaWaylandBuffer *buffer,
+                                              gpointer           user_data);
-- 
2.42.0

