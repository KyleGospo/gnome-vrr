From 80fbd6945ee70f82cc9a18ddc76267fb3157fb6a Mon Sep 17 00:00:00 2001
From: Dor Askayo <dor.askayo@gmail.com>
Date: Sun, 8 May 2022 00:09:44 +0300
Subject: [PATCH 01/25] meson: Add -Werror=strict-aliasing

This warning can point out design issues, so it should be useful to
have it treated as error.
---
 meson.build | 1 +
 1 file changed, 1 insertion(+)

diff --git a/meson.build b/meson.build
index 78f94b112..fa0cc23f0 100644
--- a/meson.build
+++ b/meson.build
@@ -427,6 +427,7 @@ if buildtype != 'plain'
     '-Werror=pointer-to-int-cast',
     '-Werror=empty-body',
     '-Werror=write-strings',
+    '-Werror=strict-aliasing',
     '-Wno-sign-compare',
     '-Wno-cast-function-type',
     '-Wno-unused-parameter',
-- 
2.36.1


From 5dc0eec32ce1ebadf6b3bec145190fed5e52de5c Mon Sep 17 00:00:00 2001
From: Dor Askayo <dor.askayo@gmail.com>
Date: Sat, 7 May 2022 23:59:06 +0300
Subject: [PATCH 02/25] tests/screen-cast: Avoid undefined behavior with
 GSource

Follow the existing convention in Mutter and avoid downcasting
custom GSource structs.
---
 src/tests/screen-cast-client.c | 42 ++++++++++++++++++++--------------
 1 file changed, 25 insertions(+), 17 deletions(-)

diff --git a/src/tests/screen-cast-client.c b/src/tests/screen-cast-client.c
index cdf0d7dcf..afd6f17b0 100644
--- a/src/tests/screen-cast-client.c
+++ b/src/tests/screen-cast-client.c
@@ -83,18 +83,18 @@ typedef struct _ScreenCast
 
 typedef struct _PipeWireSource
 {
-  GSource base;
+  GSource source;
 
   struct pw_loop *pipewire_loop;
 } PipeWireSource;
 
-static PipeWireSource *_pipewire_source;
+static GSource *_pipewire_source;
 static struct pw_context *_pipewire_context;
 static struct pw_core *_pipewire_core;
 static struct spa_hook _pipewire_core_listener;
 
 static gboolean
-pipewire_loop_source_prepare (GSource *base,
+pipewire_loop_source_prepare (GSource *source,
                               int     *timeout)
 {
   *timeout = -1;
@@ -133,24 +133,26 @@ static GSourceFuncs pipewire_source_funcs =
   pipewire_loop_source_finalize
 };
 
-static PipeWireSource *
-create_pipewire_source (void)
+static GSource *
+create_pipewire_source (struct pw_loop *pipewire_loop)
 {
+  GSource *source;
   PipeWireSource *pipewire_source;
 
-  pipewire_source =
-    (PipeWireSource *) g_source_new (&pipewire_source_funcs,
-                                     sizeof (PipeWireSource));
-  pipewire_source->pipewire_loop = pw_loop_new (NULL);
-  g_assert_nonnull (pipewire_source->pipewire_loop);
-  g_source_add_unix_fd (&pipewire_source->base,
+  source = g_source_new (&pipewire_source_funcs,
+                         sizeof (PipeWireSource));
+
+  pipewire_source = (PipeWireSource *) source;
+  pipewire_source->pipewire_loop = pipewire_loop;
+
+  g_source_add_unix_fd (source,
                         pw_loop_get_fd (pipewire_source->pipewire_loop),
                         G_IO_IN | G_IO_ERR);
 
   pw_loop_enter (pipewire_source->pipewire_loop);
-  g_source_attach (&pipewire_source->base, NULL);
+  g_source_attach (source, NULL);
 
-  return pipewire_source;
+  return source;
 }
 
 static void
@@ -171,9 +173,15 @@ static const struct pw_core_events core_events = {
 static void
 init_pipewire (void)
 {
+  struct pw_loop *pipewire_loop;
+
   pw_init (NULL, NULL);
-  _pipewire_source = create_pipewire_source ();
-  _pipewire_context = pw_context_new (_pipewire_source->pipewire_loop,
+
+  pipewire_loop = pw_loop_new (NULL);
+  g_assert_nonnull (pipewire_loop);
+
+  _pipewire_source = create_pipewire_source (pipewire_loop);
+  _pipewire_context = pw_context_new (pipewire_loop,
                                       NULL, 0);
   g_assert_nonnull (_pipewire_context);
   _pipewire_core = pw_context_connect (_pipewire_context, NULL, 0);
@@ -192,8 +200,8 @@ release_pipewire (void)
   g_clear_pointer (&_pipewire_context, pw_context_destroy);
   if (_pipewire_source)
     {
-      g_source_destroy ((GSource *) _pipewire_source);
-      g_source_unref ((GSource *) _pipewire_source);
+      g_source_destroy (_pipewire_source);
+      g_source_unref (_pipewire_source);
       _pipewire_source = NULL;
     }
 }
-- 
2.36.1


From 9c177490316ab3b6b522e108383130f976ea6b2d Mon Sep 17 00:00:00 2001
From: Dor Askayo <dor.askayo@gmail.com>
Date: Sat, 7 May 2022 23:48:22 +0300
Subject: [PATCH 03/25] screen-cast/src: Avoid undefined behavior with GSource
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

Follow the existing convention in Mutter and avoid downcasting
custom GSource structs.

This fixes the following warning:
    ../src/backends/meta-screen-cast-stream-src.c:1301:20: error: dereferencing type-punned pointer will break strict-aliasing rules [-Werror=strict-aliasing]
     1301 |   g_clear_pointer ((GSource **) &priv->pipewire_source, g_source_destroy);
    /usr/include/glib-2.0/glib/glib-typeof.h:36:36: note: in definition of macro ‘glib_typeof’
       36 | #define glib_typeof(t) __typeof__ (t)
          |                                    ^
    ../src/backends/meta-screen-cast-stream-src.c:1301:3: note: in expansion of macro ‘g_clear_pointer’
     1301 |   g_clear_pointer ((GSource **) &priv->pipewire_source, g_source_destroy);
          |   ^~~~~~~~~~~~~~~
---
 src/backends/meta-screen-cast-stream-src.c | 38 +++++++++++++---------
 1 file changed, 22 insertions(+), 16 deletions(-)

diff --git a/src/backends/meta-screen-cast-stream-src.c b/src/backends/meta-screen-cast-stream-src.c
index 1e009070c..0d8bc1751 100644
--- a/src/backends/meta-screen-cast-stream-src.c
+++ b/src/backends/meta-screen-cast-stream-src.c
@@ -78,7 +78,7 @@ static guint signals[N_SIGNALS];
 
 typedef struct _MetaPipeWireSource
 {
-  GSource base;
+  GSource source;
 
   MetaScreenCastStreamSrc *src;
   struct pw_loop *pipewire_loop;
@@ -90,7 +90,7 @@ typedef struct _MetaScreenCastStreamSrcPrivate
 
   struct pw_context *pipewire_context;
   struct pw_core *pipewire_core;
-  MetaPipeWireSource *pipewire_source;
+  GSource *pipewire_source;
   struct spa_hook pipewire_core_listener;
 
   gboolean is_enabled;
@@ -1145,7 +1145,7 @@ on_core_error (void       *data,
 }
 
 static gboolean
-pipewire_loop_source_prepare (GSource *base,
+pipewire_loop_source_prepare (GSource *source,
                               int     *timeout)
 {
   *timeout = -1;
@@ -1190,24 +1190,21 @@ static GSourceFuncs pipewire_source_funcs =
   pipewire_loop_source_finalize
 };
 
-static MetaPipeWireSource *
-create_pipewire_source (MetaScreenCastStreamSrc *src)
+static GSource *
+create_pipewire_source (MetaScreenCastStreamSrc *src,
+                        struct pw_loop          *pipewire_loop)
 {
   GSource *source;
   MetaPipeWireSource *pipewire_source;
 
   source = g_source_new (&pipewire_source_funcs, sizeof (MetaPipeWireSource));
   g_source_set_name (source, "[mutter] PipeWire");
+
   pipewire_source = (MetaPipeWireSource *) source;
   pipewire_source->src = src;
-  pipewire_source->pipewire_loop = pw_loop_new (NULL);
-  if (!pipewire_source->pipewire_loop)
-    {
-      g_source_unref ((GSource *) pipewire_source);
-      return NULL;
-    }
+  pipewire_source->pipewire_loop = pipewire_loop;
 
-  g_source_add_unix_fd (&pipewire_source->base,
+  g_source_add_unix_fd (source,
                         pw_loop_get_fd (pipewire_source->pipewire_loop),
                         G_IO_IN | G_IO_ERR);
 
@@ -1215,7 +1212,7 @@ create_pipewire_source (MetaScreenCastStreamSrc *src)
   g_source_attach (source, NULL);
   g_source_unref (source);
 
-  return pipewire_source;
+  return source;
 }
 
 static const struct pw_core_events core_events = {
@@ -1231,8 +1228,17 @@ meta_screen_cast_stream_src_initable_init (GInitable     *initable,
   MetaScreenCastStreamSrc *src = META_SCREEN_CAST_STREAM_SRC (initable);
   MetaScreenCastStreamSrcPrivate *priv =
     meta_screen_cast_stream_src_get_instance_private (src);
+  struct pw_loop *pipewire_loop;
+
+  pipewire_loop = pw_loop_new (NULL);
+  if (!pipewire_loop)
+    {
+      g_set_error (error, G_IO_ERROR, G_IO_ERROR_FAILED,
+                   "Failed to create PipeWire loop");
+      return FALSE;
+    }
 
-  priv->pipewire_source = create_pipewire_source (src);
+  priv->pipewire_source = create_pipewire_source (src, pipewire_loop);
   if (!priv->pipewire_source)
     {
       g_set_error (error, G_IO_ERROR, G_IO_ERROR_FAILED,
@@ -1240,7 +1246,7 @@ meta_screen_cast_stream_src_initable_init (GInitable     *initable,
       return FALSE;
     }
 
-  priv->pipewire_context = pw_context_new (priv->pipewire_source->pipewire_loop,
+  priv->pipewire_context = pw_context_new (pipewire_loop,
                                            NULL, 0);
   if (!priv->pipewire_context)
     {
@@ -1298,7 +1304,7 @@ meta_screen_cast_stream_src_dispose (GObject *object)
   g_clear_pointer (&priv->dmabuf_handles, g_hash_table_destroy);
   g_clear_pointer (&priv->pipewire_core, pw_core_disconnect);
   g_clear_pointer (&priv->pipewire_context, pw_context_destroy);
-  g_clear_pointer ((GSource **) &priv->pipewire_source, g_source_destroy);
+  g_clear_pointer (&priv->pipewire_source, g_source_destroy);
 
   G_OBJECT_CLASS (meta_screen_cast_stream_src_parent_class)->dispose (object);
 }
-- 
2.36.1


From b4ad970c0614a10354b0a1c096e325a9fab877fe Mon Sep 17 00:00:00 2001
From: Dor Askayo <dor.askayo@gmail.com>
Date: Sun, 5 Jun 2022 10:39:27 +0300
Subject: [PATCH 04/25] wayland/surface: Remove leftover function declarations

---
 src/wayland/meta-wayland-surface.h | 5 -----
 1 file changed, 5 deletions(-)

diff --git a/src/wayland/meta-wayland-surface.h b/src/wayland/meta-wayland-surface.h
index ccbbb7ed8..b1de0930d 100644
--- a/src/wayland/meta-wayland-surface.h
+++ b/src/wayland/meta-wayland-surface.h
@@ -306,11 +306,6 @@ gboolean            meta_wayland_surface_should_cache_state (MetaWaylandSurface
 
 MetaWindow *        meta_wayland_surface_get_toplevel_window (MetaWaylandSurface *surface);
 
-void                meta_wayland_surface_queue_pending_frame_callbacks (MetaWaylandSurface *surface);
-
-void                meta_wayland_surface_queue_pending_state_frame_callbacks (MetaWaylandSurface      *surface,
-                                                                              MetaWaylandSurfaceState *pending);
-
 void                meta_wayland_surface_get_relative_coordinates (MetaWaylandSurface *surface,
                                                                    float               abs_x,
                                                                    float               abs_y,
-- 
2.36.1


From 1016a10720e765cb836dacb5da6886b2f68715bf Mon Sep 17 00:00:00 2001
From: Dor Askayo <dor.askayo@gmail.com>
Date: Sat, 4 Jul 2020 01:03:19 +0300
Subject: [PATCH 05/25] renderer-view: Keep track of the associated MetaOutput

---
 src/backends/meta-renderer-view.c             | 24 +++++++++++++++++++
 src/backends/meta-renderer-view.h             |  2 ++
 src/backends/native/meta-renderer-native.c    |  1 +
 .../x11/nested/meta-renderer-x11-nested.c     |  1 +
 4 files changed, 28 insertions(+)

diff --git a/src/backends/meta-renderer-view.c b/src/backends/meta-renderer-view.c
index 55617fc68..2e0ddf943 100644
--- a/src/backends/meta-renderer-view.c
+++ b/src/backends/meta-renderer-view.c
@@ -33,6 +33,7 @@
 #include "backends/meta-renderer-view.h"
 
 #include "backends/meta-crtc.h"
+#include "backends/meta-output.h"
 #include "backends/meta-renderer.h"
 #include "clutter/clutter-mutter.h"
 #include "compositor/region-utils.h"
@@ -43,6 +44,7 @@ enum
 
   PROP_TRANSFORM,
   PROP_CRTC,
+  PROP_OUTPUT,
 
   PROP_LAST
 };
@@ -56,6 +58,7 @@ struct _MetaRendererView
   MetaMonitorTransform transform;
 
   MetaCrtc *crtc;
+  MetaOutput *output;
 };
 
 G_DEFINE_TYPE (MetaRendererView, meta_renderer_view,
@@ -73,6 +76,12 @@ meta_renderer_view_get_crtc (MetaRendererView *view)
   return view->crtc;
 }
 
+MetaOutput *
+meta_renderer_view_get_output (MetaRendererView *view)
+{
+  return view->output;
+}
+
 static void
 meta_renderer_view_get_offscreen_transformation_matrix (ClutterStageView  *view,
                                                         graphene_matrix_t *matrix)
@@ -174,6 +183,9 @@ meta_renderer_view_get_property (GObject    *object,
     case PROP_CRTC:
       g_value_set_object (value, view->crtc);
       break;
+    case PROP_OUTPUT:
+      g_value_set_object (value, view->output);
+      break;
     default:
       G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
       break;
@@ -196,6 +208,9 @@ meta_renderer_view_set_property (GObject      *object,
     case PROP_CRTC:
       view->crtc = g_value_get_object (value);
       break;
+    case PROP_OUTPUT:
+      view->output = g_value_get_object (value);
+      break;
     default:
       G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
       break;
@@ -243,5 +258,14 @@ meta_renderer_view_class_init (MetaRendererViewClass *klass)
                          G_PARAM_CONSTRUCT_ONLY |
                          G_PARAM_STATIC_STRINGS);
 
+  obj_props[PROP_OUTPUT] =
+    g_param_spec_object ("output",
+                         "MetaOutput",
+                         "MetaOutput",
+                         META_TYPE_OUTPUT,
+                         G_PARAM_READWRITE |
+                         G_PARAM_CONSTRUCT_ONLY |
+                         G_PARAM_STATIC_STRINGS);
+
   g_object_class_install_properties (object_class, PROP_LAST, obj_props);
 }
diff --git a/src/backends/meta-renderer-view.h b/src/backends/meta-renderer-view.h
index 3f21c7c48..ebaf7e023 100644
--- a/src/backends/meta-renderer-view.h
+++ b/src/backends/meta-renderer-view.h
@@ -31,4 +31,6 @@ MetaMonitorTransform meta_renderer_view_get_transform (MetaRendererView *view);
 
 MetaCrtc *meta_renderer_view_get_crtc (MetaRendererView *view);
 
+MetaOutput *meta_renderer_view_get_output (MetaRendererView *view);
+
 #endif /* META_RENDERER_VIEW_H */
diff --git a/src/backends/native/meta-renderer-native.c b/src/backends/native/meta-renderer-native.c
index d538cc25a..71e679671 100644
--- a/src/backends/native/meta-renderer-native.c
+++ b/src/backends/native/meta-renderer-native.c
@@ -1357,6 +1357,7 @@ meta_renderer_native_create_view (MetaRenderer       *renderer,
                        "stage", meta_backend_get_stage (backend),
                        "layout", &view_layout,
                        "crtc", crtc,
+                       "output", output,
                        "scale", scale,
                        "framebuffer", framebuffer,
                        "offscreen", offscreen,
diff --git a/src/backends/x11/nested/meta-renderer-x11-nested.c b/src/backends/x11/nested/meta-renderer-x11-nested.c
index 7c1a4facf..2f9eca5ba 100644
--- a/src/backends/x11/nested/meta-renderer-x11-nested.c
+++ b/src/backends/x11/nested/meta-renderer-x11-nested.c
@@ -223,6 +223,7 @@ meta_renderer_x11_nested_create_view (MetaRenderer       *renderer,
                        "stage", meta_backend_get_stage (backend),
                        "layout", &view_layout,
                        "crtc", crtc,
+                       "output", output,
                        "refresh-rate", mode_info->refresh_rate,
                        "framebuffer", COGL_FRAMEBUFFER (fake_onscreen),
                        "offscreen", COGL_FRAMEBUFFER (offscreen),
-- 
2.36.1


From a806bab166cdbd56d38cb6bec563677b5010ce8f Mon Sep 17 00:00:00 2001
From: Dor Askayo <dor.askayo@gmail.com>
Date: Sun, 16 Aug 2020 17:14:03 +0300
Subject: [PATCH 06/25] surface-actor: Add "frozen" signal

This signal is emitted when the surface actor is frozen and will not
update until it is thawed.
---
 src/compositor/meta-surface-actor.c | 11 +++++++++++
 1 file changed, 11 insertions(+)

diff --git a/src/compositor/meta-surface-actor.c b/src/compositor/meta-surface-actor.c
index c2bf6696a..978ccf9e6 100644
--- a/src/compositor/meta-surface-actor.c
+++ b/src/compositor/meta-surface-actor.c
@@ -51,6 +51,7 @@ enum
 {
   REPAINT_SCHEDULED,
   SIZE_CHANGED,
+  FROZEN,
 
   LAST_SIGNAL,
 };
@@ -269,6 +270,13 @@ meta_surface_actor_class_init (MetaSurfaceActorClass *klass)
                                         0,
                                         NULL, NULL, NULL,
                                         G_TYPE_NONE, 0);
+
+  signals[FROZEN] = g_signal_new ("frozen",
+                                  G_TYPE_FROM_CLASS (object_class),
+                                  G_SIGNAL_RUN_LAST,
+                                  0,
+                                  NULL, NULL, NULL,
+                                  G_TYPE_NONE, 0);
 }
 
 gboolean
@@ -594,6 +602,9 @@ meta_surface_actor_set_frozen (MetaSurfaceActor *self,
 
   priv->frozen = frozen;
 
+  if (frozen)
+    g_signal_emit (self, signals[FROZEN], 0);
+
   if (!frozen && priv->pending_damage)
     {
       int i, n_rects = cairo_region_num_rectangles (priv->pending_damage);
-- 
2.36.1


From d9dc91b022f25cb326290c87cfcf65553c5863de Mon Sep 17 00:00:00 2001
From: Dor Askayo <dor.askayo@gmail.com>
Date: Sun, 16 Aug 2020 19:50:45 +0300
Subject: [PATCH 07/25] clutter/stage: Allow scheduling stage updates in the
 context of an actor

This is required synchronizing the frame clock to the update rate of
specific actors in later commits.
---
 clutter/clutter/clutter-stage-view-private.h |  4 +++
 clutter/clutter/clutter-stage-view.c         | 18 ++++++++++++
 clutter/clutter/clutter-stage-view.h         |  3 ++
 clutter/clutter/clutter-stage.c              | 30 ++++++++++++++++++++
 clutter/clutter/clutter-stage.h              |  4 +++
 5 files changed, 59 insertions(+)

diff --git a/clutter/clutter/clutter-stage-view-private.h b/clutter/clutter/clutter-stage-view-private.h
index 39d8601ea..5c1ce9645 100644
--- a/clutter/clutter/clutter-stage-view-private.h
+++ b/clutter/clutter/clutter-stage-view-private.h
@@ -72,6 +72,10 @@ void clutter_stage_view_transform_rect_to_onscreen (ClutterStageView
 CLUTTER_EXPORT
 void clutter_stage_view_schedule_update (ClutterStageView *view);
 
+CLUTTER_EXPORT
+void clutter_stage_view_schedule_actor_update (ClutterStageView *view,
+                                               ClutterActor     *actor);
+
 CLUTTER_EXPORT
 void clutter_stage_view_notify_presented (ClutterStageView *view,
                                           ClutterFrameInfo *frame_info);
diff --git a/clutter/clutter/clutter-stage-view.c b/clutter/clutter/clutter-stage-view.c
index 2e47237f0..55d4368bc 100644
--- a/clutter/clutter/clutter-stage-view.c
+++ b/clutter/clutter/clutter-stage-view.c
@@ -1047,6 +1047,22 @@ clutter_stage_view_schedule_update (ClutterStageView *view)
   clutter_frame_clock_schedule_update (priv->frame_clock);
 }
 
+void
+clutter_stage_view_schedule_actor_update (ClutterStageView *view,
+                                          ClutterActor     *actor)
+{
+  ClutterStageViewClass *view_class = CLUTTER_STAGE_VIEW_GET_CLASS (view);
+
+  view_class->schedule_actor_update (view, actor);
+}
+
+static void
+clutter_stage_view_real_schedule_actor_update (ClutterStageView *view,
+                                               ClutterActor     *actor)
+{
+  clutter_stage_view_schedule_update (view);
+}
+
 float
 clutter_stage_view_get_refresh_rate (ClutterStageView *view)
 {
@@ -1443,6 +1459,8 @@ clutter_stage_view_class_init (ClutterStageViewClass *klass)
   object_class->dispose = clutter_stage_view_dispose;
   object_class->finalize = clutter_stage_view_finalize;
 
+  klass->schedule_actor_update = clutter_stage_view_real_schedule_actor_update;
+
   obj_props[PROP_NAME] =
     g_param_spec_string ("name",
                          "Name",
diff --git a/clutter/clutter/clutter-stage-view.h b/clutter/clutter/clutter-stage-view.h
index c2cf76abf..0f34cf5b8 100644
--- a/clutter/clutter/clutter-stage-view.h
+++ b/clutter/clutter/clutter-stage-view.h
@@ -50,6 +50,9 @@ struct _ClutterStageViewClass
                                        int                          dst_width,
                                        int                          dst_height,
                                        cairo_rectangle_int_t       *dst_rect);
+
+  void (* schedule_actor_update) (ClutterStageView *view,
+                                  ClutterActor     *actor);
 };
 
 CLUTTER_EXPORT
diff --git a/clutter/clutter/clutter-stage.c b/clutter/clutter/clutter-stage.c
index e97cd54a3..3e81655e0 100644
--- a/clutter/clutter/clutter-stage.c
+++ b/clutter/clutter/clutter-stage.c
@@ -2467,6 +2467,36 @@ clutter_stage_schedule_update (ClutterStage *stage)
     }
 }
 
+/**
+ * clutter_stage_schedule_actor_update:
+ * @stage: a #ClutterStage actor
+ * @actor: a #ClutterActor which requires an update
+ *
+ * Schedules a redraw of the #ClutterStage at the next optimal timestamp
+ * for the specified actor.
+ */
+void
+clutter_stage_schedule_actor_update (ClutterStage *stage,
+                                     ClutterActor *actor)
+{
+  ClutterStageWindow *stage_window;
+  GList *l;
+
+  if (CLUTTER_ACTOR_IN_DESTRUCTION (stage))
+    return;
+
+  stage_window = _clutter_stage_get_window (stage);
+  if (stage_window == NULL)
+    return;
+
+  for (l = clutter_stage_peek_stage_views (stage); l; l = l->next)
+    {
+      ClutterStageView *view = l->data;
+
+      clutter_stage_view_schedule_actor_update (view, actor);
+    }
+}
+
 ClutterPaintVolume *
 _clutter_stage_paint_volume_stack_allocate (ClutterStage *stage)
 {
diff --git a/clutter/clutter/clutter-stage.h b/clutter/clutter/clutter-stage.h
index 5412c4d72..a579820a4 100644
--- a/clutter/clutter/clutter-stage.h
+++ b/clutter/clutter/clutter-stage.h
@@ -210,6 +210,10 @@ gboolean        clutter_stage_is_redraw_queued_on_view          (ClutterStage
 CLUTTER_EXPORT
 void clutter_stage_schedule_update (ClutterStage *stage);
 
+CLUTTER_EXPORT
+void clutter_stage_schedule_actor_update (ClutterStage *stage,
+                                          ClutterActor *actor);
+
 CLUTTER_EXPORT
 gboolean clutter_stage_get_capture_final_size (ClutterStage          *stage,
                                                cairo_rectangle_int_t *rect,
-- 
2.36.1


From 4a996b4d64e9ee35140d752f6231879aec8c8e7c Mon Sep 17 00:00:00 2001
From: Dor Askayo <dor.askayo@gmail.com>
Date: Sat, 13 Mar 2021 12:55:09 +0200
Subject: [PATCH 08/25] clutter/frame-clock: Simplify logic around early
 presented event

A few calculations and assignments are done unnecessarily when the
last next presentation time is invalid. This increases the cognitive
complexity of the function for no reason.
---
 clutter/clutter/clutter-frame-clock.c | 46 +++++++++++++--------------
 1 file changed, 23 insertions(+), 23 deletions(-)

diff --git a/clutter/clutter/clutter-frame-clock.c b/clutter/clutter/clutter-frame-clock.c
index 6fa2b2588..abf18f0a1 100644
--- a/clutter/clutter/clutter-frame-clock.c
+++ b/clutter/clutter/clutter-frame-clock.c
@@ -406,8 +406,6 @@ calculate_next_update_time_us (ClutterFrameClock *frame_clock,
   int64_t refresh_interval_us;
   int64_t min_render_time_allowed_us;
   int64_t max_render_time_allowed_us;
-  int64_t last_next_presentation_time_us;
-  int64_t time_since_last_next_presentation_time_us;
   int64_t next_presentation_time_us;
   int64_t next_update_time_us;
 
@@ -509,28 +507,30 @@ calculate_next_update_time_us (ClutterFrameClock *frame_clock,
         refresh_interval_us;
     }
 
-  /*
-   * Skip one interval if we got an early presented event.
-   *
-   *        last frame this was last_presentation_time
-   *       /       frame_clock->next_presentation_time_us
-   *      /       /
-   * |---|-o-----|-x----->
-   *       |       \
-   *       \        next_presentation_time_us is thus right after the last one
-   *        but got an unexpected early presentation
-   *             \_/
-   *             time_since_last_next_presentation_time_us
-   *
-   */
-  last_next_presentation_time_us = frame_clock->next_presentation_time_us;
-  time_since_last_next_presentation_time_us =
-    next_presentation_time_us - last_next_presentation_time_us;
-  if (frame_clock->is_next_presentation_time_valid &&
-      time_since_last_next_presentation_time_us < (refresh_interval_us / 2))
+  if (G_LIKELY (frame_clock->is_next_presentation_time_valid))
     {
-      next_presentation_time_us =
-        frame_clock->next_presentation_time_us + refresh_interval_us;
+      int64_t time_since_last_next_presentation_time_us =
+          next_presentation_time_us - frame_clock->next_presentation_time_us;
+
+      /*
+       * Skip one interval if we got an early presented event.
+       *
+       *        last frame this was last_presentation_time
+       *       /       frame_clock->next_presentation_time_us
+       *      /       /
+       * |---|-o-----|-x----->
+       *       |       \
+       *       \        next_presentation_time_us is thus right after the last one
+       *        but got an unexpected early presentation
+       *             \_/
+       *             time_since_last_next_presentation_time_us
+       *
+       */
+      if (time_since_last_next_presentation_time_us < (refresh_interval_us / 2))
+        {
+          next_presentation_time_us =
+            frame_clock->next_presentation_time_us + refresh_interval_us;
+        }
     }
 
   while (next_presentation_time_us < now_us + min_render_time_allowed_us)
-- 
2.36.1


From 8d376da466ff9e7f4a96c16cbf79d32c07a53396 Mon Sep 17 00:00:00 2001
From: Dor Askayo <dor.askayo@gmail.com>
Date: Tue, 4 Aug 2020 00:28:12 +0300
Subject: [PATCH 09/25] clutter/frame-clock: Add a mode for variable scheduling

A new variable mode is introduced which allows:
* Immediate update scheduling, even when an update is already
  scheduled.
* A timeout-based frame scheduling for every other update.

This mode will be used by following commits to implement
synchronization of page flips to actor frames.
---
 clutter/clutter/clutter-frame-clock.c | 144 ++++++++++++++++++++------
 clutter/clutter/clutter-frame-clock.h |  10 ++
 2 files changed, 121 insertions(+), 33 deletions(-)

diff --git a/clutter/clutter/clutter-frame-clock.c b/clutter/clutter/clutter-frame-clock.c
index abf18f0a1..3188603bd 100644
--- a/clutter/clutter/clutter-frame-clock.c
+++ b/clutter/clutter/clutter-frame-clock.c
@@ -47,6 +47,9 @@ typedef struct _EstimateQueue
 
 #define SYNC_DELAY_FALLBACK_FRACTION 0.875
 
+#define PRESENTATION_TIME_INVALID -1
+#define MINIMUM_REFRESH_RATE 30
+
 typedef struct _ClutterFrameListener
 {
   const ClutterFrameListenerIface *iface;
@@ -62,8 +65,8 @@ typedef struct _ClutterClockSource
 
 typedef enum _ClutterFrameClockState
 {
-  CLUTTER_FRAME_CLOCK_STATE_INIT,
   CLUTTER_FRAME_CLOCK_STATE_IDLE,
+  CLUTTER_FRAME_CLOCK_STATE_IDLE_TIMEOUT,
   CLUTTER_FRAME_CLOCK_STATE_SCHEDULED,
   CLUTTER_FRAME_CLOCK_STATE_DISPATCHING,
   CLUTTER_FRAME_CLOCK_STATE_PENDING_PRESENTED,
@@ -75,6 +78,8 @@ struct _ClutterFrameClock
 
   float refresh_rate;
   int64_t refresh_interval_us;
+  int64_t minimum_refresh_interval_us;
+
   ClutterFrameListener listener;
 
   GSource *source;
@@ -82,11 +87,12 @@ struct _ClutterFrameClock
   int64_t frame_count;
 
   ClutterFrameClockState state;
+  ClutterFrameClockMode mode;
+
   int64_t last_dispatch_time_us;
   int64_t last_dispatch_lateness_us;
-  int64_t last_presentation_time_us;
 
-  gboolean is_next_presentation_time_valid;
+  int64_t last_presentation_time_us;
   int64_t next_presentation_time_us;
 
   /* Buffer must be submitted to KMS and GPU rendering must be finished
@@ -270,7 +276,10 @@ clutter_frame_clock_notify_presented (ClutterFrameClock *frame_clock,
     }
 #endif
 
-  frame_clock->last_presentation_time_us = frame_info->presentation_time;
+  if (frame_info->presentation_time > 0)
+    frame_clock->last_presentation_time_us = frame_info->presentation_time;
+  else
+    frame_clock->last_presentation_time_us = PRESENTATION_TIME_INVALID;
 
   frame_clock->got_measurements_last_frame = FALSE;
 
@@ -312,8 +321,8 @@ clutter_frame_clock_notify_presented (ClutterFrameClock *frame_clock,
 
   switch (frame_clock->state)
     {
-    case CLUTTER_FRAME_CLOCK_STATE_INIT:
     case CLUTTER_FRAME_CLOCK_STATE_IDLE:
+    case CLUTTER_FRAME_CLOCK_STATE_IDLE_TIMEOUT:
     case CLUTTER_FRAME_CLOCK_STATE_SCHEDULED:
       g_warn_if_reached ();
       break;
@@ -332,8 +341,8 @@ clutter_frame_clock_notify_ready (ClutterFrameClock *frame_clock)
 
   switch (frame_clock->state)
     {
-    case CLUTTER_FRAME_CLOCK_STATE_INIT:
     case CLUTTER_FRAME_CLOCK_STATE_IDLE:
+    case CLUTTER_FRAME_CLOCK_STATE_IDLE_TIMEOUT:
     case CLUTTER_FRAME_CLOCK_STATE_SCHEDULED:
       g_warn_if_reached ();
       break;
@@ -398,12 +407,12 @@ clutter_frame_clock_compute_max_render_time_us (ClutterFrameClock *frame_clock)
 
 static void
 calculate_next_update_time_us (ClutterFrameClock *frame_clock,
+                               int64_t            refresh_interval_us,
                                int64_t           *out_next_update_time_us,
                                int64_t           *out_next_presentation_time_us)
 {
   int64_t last_presentation_time_us;
   int64_t now_us;
-  int64_t refresh_interval_us;
   int64_t min_render_time_allowed_us;
   int64_t max_render_time_allowed_us;
   int64_t next_presentation_time_us;
@@ -411,9 +420,9 @@ calculate_next_update_time_us (ClutterFrameClock *frame_clock,
 
   now_us = g_get_monotonic_time ();
 
-  refresh_interval_us = frame_clock->refresh_interval_us;
+  last_presentation_time_us = frame_clock->last_presentation_time_us;
 
-  if (frame_clock->last_presentation_time_us == 0)
+  if (last_presentation_time_us == PRESENTATION_TIME_INVALID)
     {
       *out_next_update_time_us =
         frame_clock->last_dispatch_time_us ?
@@ -421,8 +430,9 @@ calculate_next_update_time_us (ClutterFrameClock *frame_clock,
           frame_clock->last_dispatch_lateness_us) + refresh_interval_us) :
         now_us;
 
-      *out_next_presentation_time_us = 0;
+      *out_next_presentation_time_us = PRESENTATION_TIME_INVALID;
       return;
+
     }
 
   min_render_time_allowed_us = refresh_interval_us / 2;
@@ -449,7 +459,6 @@ calculate_next_update_time_us (ClutterFrameClock *frame_clock,
    * 0
    *
    */
-  last_presentation_time_us = frame_clock->last_presentation_time_us;
   next_presentation_time_us = last_presentation_time_us + refresh_interval_us;
 
   /*
@@ -507,7 +516,7 @@ calculate_next_update_time_us (ClutterFrameClock *frame_clock,
         refresh_interval_us;
     }
 
-  if (G_LIKELY (frame_clock->is_next_presentation_time_valid))
+  if (G_LIKELY (frame_clock->next_presentation_time_us != PRESENTATION_TIME_INVALID))
     {
       int64_t time_since_last_next_presentation_time_us =
           next_presentation_time_us - frame_clock->next_presentation_time_us;
@@ -542,6 +551,37 @@ calculate_next_update_time_us (ClutterFrameClock *frame_clock,
   *out_next_presentation_time_us = next_presentation_time_us;
 }
 
+static void
+calculate_timeout_update_time_us (ClutterFrameClock *frame_clock,
+                                  int64_t            timeout_us,
+                                  int64_t           *out_next_update_time_us)
+{
+  int64_t now_us;
+  int64_t last_presentation_time_us;
+  int64_t next_update_time_us;
+
+  now_us = g_get_monotonic_time ();
+
+  last_presentation_time_us = frame_clock->last_presentation_time_us;
+
+  if (last_presentation_time_us == PRESENTATION_TIME_INVALID)
+    {
+      *out_next_update_time_us =
+        frame_clock->last_dispatch_time_us ?
+        ((frame_clock->last_dispatch_time_us -
+          frame_clock->last_dispatch_lateness_us) + timeout_us) :
+        now_us;
+      return;
+    }
+
+  next_update_time_us = last_presentation_time_us + timeout_us;
+
+  while (next_update_time_us < now_us)
+    next_update_time_us += timeout_us;
+
+  *out_next_update_time_us = next_update_time_us;
+}
+
 void
 clutter_frame_clock_inhibit (ClutterFrameClock *frame_clock)
 {
@@ -551,9 +591,9 @@ clutter_frame_clock_inhibit (ClutterFrameClock *frame_clock)
     {
       switch (frame_clock->state)
         {
-        case CLUTTER_FRAME_CLOCK_STATE_INIT:
         case CLUTTER_FRAME_CLOCK_STATE_IDLE:
           break;
+        case CLUTTER_FRAME_CLOCK_STATE_IDLE_TIMEOUT:
         case CLUTTER_FRAME_CLOCK_STATE_SCHEDULED:
           frame_clock->pending_reschedule = TRUE;
           frame_clock->state = CLUTTER_FRAME_CLOCK_STATE_IDLE;
@@ -581,8 +621,6 @@ clutter_frame_clock_uninhibit (ClutterFrameClock *frame_clock)
 void
 clutter_frame_clock_schedule_update_now (ClutterFrameClock *frame_clock)
 {
-  int64_t next_update_time_us = -1;
-
   if (frame_clock->inhibit_count > 0)
     {
       frame_clock->pending_reschedule = TRUE;
@@ -592,9 +630,8 @@ clutter_frame_clock_schedule_update_now (ClutterFrameClock *frame_clock)
 
   switch (frame_clock->state)
     {
-    case CLUTTER_FRAME_CLOCK_STATE_INIT:
     case CLUTTER_FRAME_CLOCK_STATE_IDLE:
-      next_update_time_us = g_get_monotonic_time ();
+    case CLUTTER_FRAME_CLOCK_STATE_IDLE_TIMEOUT:
       break;
     case CLUTTER_FRAME_CLOCK_STATE_SCHEDULED:
       return;
@@ -605,11 +642,9 @@ clutter_frame_clock_schedule_update_now (ClutterFrameClock *frame_clock)
       return;
     }
 
-  g_warn_if_fail (next_update_time_us != -1);
-
-  g_source_set_ready_time (frame_clock->source, next_update_time_us);
+  g_source_set_ready_time (frame_clock->source, 0);
+  frame_clock->next_presentation_time_us = PRESENTATION_TIME_INVALID;
   frame_clock->state = CLUTTER_FRAME_CLOCK_STATE_SCHEDULED;
-  frame_clock->is_next_presentation_time_valid = FALSE;
 }
 
 void
@@ -625,16 +660,9 @@ clutter_frame_clock_schedule_update (ClutterFrameClock *frame_clock)
 
   switch (frame_clock->state)
     {
-    case CLUTTER_FRAME_CLOCK_STATE_INIT:
-      next_update_time_us = g_get_monotonic_time ();
-      break;
     case CLUTTER_FRAME_CLOCK_STATE_IDLE:
-      calculate_next_update_time_us (frame_clock,
-                                     &next_update_time_us,
-                                     &frame_clock->next_presentation_time_us);
-      frame_clock->is_next_presentation_time_valid =
-        (frame_clock->next_presentation_time_us != 0);
       break;
+    case CLUTTER_FRAME_CLOCK_STATE_IDLE_TIMEOUT:
     case CLUTTER_FRAME_CLOCK_STATE_SCHEDULED:
       return;
     case CLUTTER_FRAME_CLOCK_STATE_DISPATCHING:
@@ -643,10 +671,53 @@ clutter_frame_clock_schedule_update (ClutterFrameClock *frame_clock)
       return;
     }
 
+  switch (frame_clock->mode)
+    {
+    case CLUTTER_FRAME_CLOCK_MODE_FIXED:
+      calculate_next_update_time_us (frame_clock,
+                                     frame_clock->refresh_interval_us,
+                                     &next_update_time_us,
+                                     &frame_clock->next_presentation_time_us);
+      frame_clock->state = CLUTTER_FRAME_CLOCK_STATE_SCHEDULED;
+      break;
+    case CLUTTER_FRAME_CLOCK_MODE_VARIABLE:
+      calculate_timeout_update_time_us (frame_clock,
+                                        frame_clock->minimum_refresh_interval_us,
+                                        &next_update_time_us);
+      frame_clock->next_presentation_time_us = PRESENTATION_TIME_INVALID;
+      frame_clock->state = CLUTTER_FRAME_CLOCK_STATE_IDLE_TIMEOUT;
+      break;
+    }
+
   g_warn_if_fail (next_update_time_us != -1);
 
   g_source_set_ready_time (frame_clock->source, next_update_time_us);
-  frame_clock->state = CLUTTER_FRAME_CLOCK_STATE_SCHEDULED;
+}
+
+void
+clutter_frame_clock_set_mode (ClutterFrameClock     *frame_clock,
+                              ClutterFrameClockMode  mode)
+{
+  if (frame_clock->mode == mode)
+    return;
+
+  frame_clock->mode = mode;
+
+  switch (frame_clock->state)
+    {
+    case CLUTTER_FRAME_CLOCK_STATE_IDLE:
+      break;
+    case CLUTTER_FRAME_CLOCK_STATE_IDLE_TIMEOUT:
+    case CLUTTER_FRAME_CLOCK_STATE_SCHEDULED:
+      frame_clock->state = CLUTTER_FRAME_CLOCK_STATE_IDLE;
+      frame_clock->pending_reschedule = TRUE;
+      break;
+    case CLUTTER_FRAME_CLOCK_STATE_DISPATCHING:
+    case CLUTTER_FRAME_CLOCK_STATE_PENDING_PRESENTED:
+      break;
+    }
+
+  maybe_reschedule_update (frame_clock);
 }
 
 static void
@@ -692,7 +763,7 @@ clutter_frame_clock_dispatch (ClutterFrameClock *frame_clock,
   COGL_TRACE_END (ClutterFrameClockEvents);
 
   COGL_TRACE_BEGIN (ClutterFrameClockTimelines, "Frame Clock (timelines)");
-  if (frame_clock->is_next_presentation_time_valid)
+  if (frame_clock->next_presentation_time_us != PRESENTATION_TIME_INVALID)
     time_us = frame_clock->next_presentation_time_us;
   advance_timelines (frame_clock, time_us);
   COGL_TRACE_END (ClutterFrameClockTimelines);
@@ -705,11 +776,11 @@ clutter_frame_clock_dispatch (ClutterFrameClock *frame_clock,
 
   switch (frame_clock->state)
     {
-    case CLUTTER_FRAME_CLOCK_STATE_INIT:
     case CLUTTER_FRAME_CLOCK_STATE_PENDING_PRESENTED:
       g_warn_if_reached ();
       break;
     case CLUTTER_FRAME_CLOCK_STATE_IDLE:
+    case CLUTTER_FRAME_CLOCK_STATE_IDLE_TIMEOUT:
     case CLUTTER_FRAME_CLOCK_STATE_SCHEDULED:
       break;
     case CLUTTER_FRAME_CLOCK_STATE_DISPATCHING:
@@ -850,6 +921,10 @@ clutter_frame_clock_new (float                            refresh_rate,
   init_frame_clock_source (frame_clock);
 
   clutter_frame_clock_set_refresh_rate (frame_clock, refresh_rate);
+
+  frame_clock->minimum_refresh_interval_us =
+    (int64_t) (0.5 + G_USEC_PER_SEC / MINIMUM_REFRESH_RATE);
+
   frame_clock->vblank_duration_us = vblank_duration_us;
 
   return frame_clock;
@@ -880,7 +955,10 @@ clutter_frame_clock_dispose (GObject *object)
 static void
 clutter_frame_clock_init (ClutterFrameClock *frame_clock)
 {
-  frame_clock->state = CLUTTER_FRAME_CLOCK_STATE_INIT;
+  frame_clock->state = CLUTTER_FRAME_CLOCK_STATE_IDLE;
+  frame_clock->mode = CLUTTER_FRAME_CLOCK_MODE_FIXED;
+  frame_clock->last_presentation_time_us = PRESENTATION_TIME_INVALID;
+  frame_clock->next_presentation_time_us = PRESENTATION_TIME_INVALID;
 }
 
 static void
diff --git a/clutter/clutter/clutter-frame-clock.h b/clutter/clutter/clutter-frame-clock.h
index 91e6b3a13..0b2325a56 100644
--- a/clutter/clutter/clutter-frame-clock.h
+++ b/clutter/clutter/clutter-frame-clock.h
@@ -53,6 +53,12 @@ typedef struct _ClutterFrameListenerIface
                                 gpointer           user_data);
 } ClutterFrameListenerIface;
 
+typedef enum _ClutterFrameClockMode
+{
+  CLUTTER_FRAME_CLOCK_MODE_FIXED,
+  CLUTTER_FRAME_CLOCK_MODE_VARIABLE
+} ClutterFrameClockMode;
+
 CLUTTER_EXPORT
 ClutterFrameClock * clutter_frame_clock_new (float                            refresh_rate,
                                              int64_t                          vblank_duration_us,
@@ -62,6 +68,10 @@ ClutterFrameClock * clutter_frame_clock_new (float                            re
 CLUTTER_EXPORT
 void clutter_frame_clock_destroy (ClutterFrameClock *frame_clock);
 
+CLUTTER_EXPORT
+void clutter_frame_clock_set_mode (ClutterFrameClock     *frame_clock,
+                                   ClutterFrameClockMode  mode);
+
 CLUTTER_EXPORT
 void clutter_frame_clock_notify_presented (ClutterFrameClock *frame_clock,
                                            ClutterFrameInfo  *frame_info);
-- 
2.36.1


From 74df318fb2f1ef715b5cdd7f15ccee8cbaf20373 Mon Sep 17 00:00:00 2001
From: Dor Askayo <dor.askayo@gmail.com>
Date: Fri, 10 Jul 2020 18:40:07 +0300
Subject: [PATCH 10/25] backends/native: Introduce MetaRendererViewNative

MetaRendererViewNative is a MetaRendererView which contains logic
specific to views of the native backend. It will be used by following
commits.

In the future, per-view logic from MetaRendererNative can be moved to
MetaRendererViewNative where it makes more sense to have it.
---
 src/backends/meta-renderer-view.c             | 54 ++++++++++++-------
 src/backends/meta-renderer-view.h             | 11 ++--
 src/backends/native/meta-renderer-native.c    | 36 +++++++------
 .../native/meta-renderer-view-native.c        | 43 +++++++++++++++
 .../native/meta-renderer-view-native.h        | 34 ++++++++++++
 src/meson.build                               |  2 +
 6 files changed, 142 insertions(+), 38 deletions(-)
 create mode 100644 src/backends/native/meta-renderer-view-native.c
 create mode 100644 src/backends/native/meta-renderer-view-native.h

diff --git a/src/backends/meta-renderer-view.c b/src/backends/meta-renderer-view.c
index 2e0ddf943..348ce0fb8 100644
--- a/src/backends/meta-renderer-view.c
+++ b/src/backends/meta-renderer-view.c
@@ -51,35 +51,42 @@ enum
 
 static GParamSpec *obj_props[PROP_LAST];
 
-struct _MetaRendererView
+typedef struct _MetaRendererViewPrivate
 {
-  MetaStageView parent;
-
   MetaMonitorTransform transform;
 
   MetaCrtc *crtc;
   MetaOutput *output;
-};
+} MetaRendererViewPrivate;
 
-G_DEFINE_TYPE (MetaRendererView, meta_renderer_view,
-               META_TYPE_STAGE_VIEW)
+G_DEFINE_TYPE_WITH_PRIVATE (MetaRendererView, meta_renderer_view,
+                            META_TYPE_STAGE_VIEW)
 
 MetaMonitorTransform
 meta_renderer_view_get_transform (MetaRendererView *view)
 {
-  return view->transform;
+  MetaRendererViewPrivate *priv =
+    meta_renderer_view_get_instance_private (view);
+
+  return priv->transform;
 }
 
 MetaCrtc *
 meta_renderer_view_get_crtc (MetaRendererView *view)
 {
-  return view->crtc;
+  MetaRendererViewPrivate *priv =
+    meta_renderer_view_get_instance_private (view);
+
+  return priv->crtc;
 }
 
 MetaOutput *
 meta_renderer_view_get_output (MetaRendererView *view)
 {
-  return view->output;
+  MetaRendererViewPrivate *priv =
+    meta_renderer_view_get_instance_private (view);
+
+  return priv->output;
 }
 
 static void
@@ -87,10 +94,12 @@ meta_renderer_view_get_offscreen_transformation_matrix (ClutterStageView  *view,
                                                         graphene_matrix_t *matrix)
 {
   MetaRendererView *renderer_view = META_RENDERER_VIEW (view);
+  MetaRendererViewPrivate *priv =
+    meta_renderer_view_get_instance_private (renderer_view);
 
   graphene_matrix_init_identity (matrix);
 
-  switch (renderer_view->transform)
+  switch (priv->transform)
     {
     case META_MONITOR_TRANSFORM_NORMAL:
       break;
@@ -145,10 +154,12 @@ meta_renderer_view_transform_rect_to_onscreen (ClutterStageView            *view
                                                cairo_rectangle_int_t       *dst_rect)
 {
   MetaRendererView *renderer_view = META_RENDERER_VIEW (view);
+  MetaRendererViewPrivate *priv =
+    meta_renderer_view_get_instance_private (renderer_view);
   MetaMonitorTransform inverted_transform;
 
   inverted_transform =
-    meta_monitor_transform_invert (renderer_view->transform);
+    meta_monitor_transform_invert (priv->transform);
   return meta_rectangle_transform (src_rect,
                                    inverted_transform,
                                    dst_width,
@@ -160,10 +171,13 @@ static void
 meta_renderer_view_set_transform (MetaRendererView     *view,
                                   MetaMonitorTransform  transform)
 {
-  if (view->transform == transform)
+  MetaRendererViewPrivate *priv =
+    meta_renderer_view_get_instance_private (view);
+
+  if (priv->transform == transform)
     return;
 
-  view->transform = transform;
+  priv->transform = transform;
   clutter_stage_view_invalidate_offscreen_blit_pipeline (CLUTTER_STAGE_VIEW (view));
 }
 
@@ -174,17 +188,19 @@ meta_renderer_view_get_property (GObject    *object,
                                  GParamSpec *pspec)
 {
   MetaRendererView *view = META_RENDERER_VIEW (object);
+  MetaRendererViewPrivate *priv =
+    meta_renderer_view_get_instance_private (view);
 
   switch (prop_id)
     {
     case PROP_TRANSFORM:
-      g_value_set_uint (value, view->transform);
+      g_value_set_uint (value, priv->transform);
       break;
     case PROP_CRTC:
-      g_value_set_object (value, view->crtc);
+      g_value_set_object (value, priv->crtc);
       break;
     case PROP_OUTPUT:
-      g_value_set_object (value, view->output);
+      g_value_set_object (value, priv->output);
       break;
     default:
       G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
@@ -199,6 +215,8 @@ meta_renderer_view_set_property (GObject      *object,
                                  GParamSpec   *pspec)
 {
   MetaRendererView *view = META_RENDERER_VIEW (object);
+  MetaRendererViewPrivate *priv =
+    meta_renderer_view_get_instance_private (view);
 
   switch (prop_id)
     {
@@ -206,10 +224,10 @@ meta_renderer_view_set_property (GObject      *object,
       meta_renderer_view_set_transform (view, g_value_get_uint (value));
       break;
     case PROP_CRTC:
-      view->crtc = g_value_get_object (value);
+      priv->crtc = g_value_get_object (value);
       break;
     case PROP_OUTPUT:
-      view->output = g_value_get_object (value);
+      priv->output = g_value_get_object (value);
       break;
     default:
       G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
diff --git a/src/backends/meta-renderer-view.h b/src/backends/meta-renderer-view.h
index ebaf7e023..d0a516661 100644
--- a/src/backends/meta-renderer-view.h
+++ b/src/backends/meta-renderer-view.h
@@ -23,9 +23,14 @@
 #include "backends/meta-stage-view-private.h"
 
 #define META_TYPE_RENDERER_VIEW (meta_renderer_view_get_type ())
-G_DECLARE_FINAL_TYPE (MetaRendererView, meta_renderer_view,
-                      META, RENDERER_VIEW,
-                      MetaStageView)
+G_DECLARE_DERIVABLE_TYPE (MetaRendererView, meta_renderer_view,
+                          META, RENDERER_VIEW,
+                          MetaStageView)
+
+struct _MetaRendererViewClass
+{
+  MetaStageViewClass parent_class;
+};
 
 MetaMonitorTransform meta_renderer_view_get_transform (MetaRendererView *view);
 
diff --git a/src/backends/native/meta-renderer-native.c b/src/backends/native/meta-renderer-native.c
index 71e679671..fdfe4a35f 100644
--- a/src/backends/native/meta-renderer-native.c
+++ b/src/backends/native/meta-renderer-native.c
@@ -61,6 +61,7 @@
 #include "backends/native/meta-output-kms.h"
 #include "backends/native/meta-render-device-gbm.h"
 #include "backends/native/meta-render-device-surfaceless.h"
+#include "backends/native/meta-renderer-view-native.h"
 #include "backends/native/meta-renderer-native-private.h"
 #include "cogl/cogl.h"
 #include "core/boxes-private.h"
@@ -1240,7 +1241,7 @@ meta_renderer_native_create_view (MetaRenderer       *renderer,
   int onscreen_width;
   int onscreen_height;
   MetaRectangle view_layout;
-  MetaRendererView *view;
+  MetaRendererViewNative *view_native;
   EGLSurface egl_surface;
   GError *error = NULL;
 
@@ -1352,27 +1353,28 @@ meta_renderer_native_create_view (MetaRenderer       *renderer,
   meta_rectangle_from_graphene_rect (&crtc_config->layout,
                                      META_ROUNDING_STRATEGY_ROUND,
                                      &view_layout);
-  view = g_object_new (META_TYPE_RENDERER_VIEW,
-                       "name", meta_output_get_name (output),
-                       "stage", meta_backend_get_stage (backend),
-                       "layout", &view_layout,
-                       "crtc", crtc,
-                       "output", output,
-                       "scale", scale,
-                       "framebuffer", framebuffer,
-                       "offscreen", offscreen,
-                       "use-shadowfb", use_shadowfb,
-                       "transform", view_transform,
-                       "refresh-rate", crtc_mode_info->refresh_rate,
-                       "vblank-duration-us", crtc_mode_info->vblank_duration_us,
-                       NULL);
+  view_native = g_object_new (META_TYPE_RENDERER_VIEW_NATIVE,
+                              "name", meta_output_get_name (output),
+                              "stage", meta_backend_get_stage (backend),
+                              "layout", &view_layout,
+                              "crtc", crtc,
+                              "output", output,
+                              "scale", scale,
+                              "framebuffer", framebuffer,
+                              "offscreen", offscreen,
+                              "use-shadowfb", use_shadowfb,
+                              "transform", view_transform,
+                              "refresh-rate", crtc_mode_info->refresh_rate,
+                              "vblank-duration-us", crtc_mode_info->vblank_duration_us,
+                              NULL);
 
   if (META_IS_ONSCREEN_NATIVE (framebuffer))
     {
       CoglDisplayEGL *cogl_display_egl;
       CoglOnscreenEgl *onscreen_egl;
 
-      meta_onscreen_native_set_view (COGL_ONSCREEN (framebuffer), view);
+      meta_onscreen_native_set_view (COGL_ONSCREEN (framebuffer),
+                                     META_RENDERER_VIEW (view_native));
 
       /* Ensure we don't point to stale surfaces when creating the offscreen */
       cogl_display_egl = cogl_display->winsys;
@@ -1384,7 +1386,7 @@ meta_renderer_native_create_view (MetaRenderer       *renderer,
                                      cogl_display_egl->egl_context);
     }
 
-  return view;
+  return META_RENDERER_VIEW (view_native);
 }
 
 static void
diff --git a/src/backends/native/meta-renderer-view-native.c b/src/backends/native/meta-renderer-view-native.c
new file mode 100644
index 000000000..38fd0453d
--- /dev/null
+++ b/src/backends/native/meta-renderer-view-native.c
@@ -0,0 +1,43 @@
+/* -*- mode: C; c-file-style: "gnu"; indent-tabs-mode: nil; -*- */
+
+/*
+ * Copyright (C) 2020 Dor Askayo
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of the
+ * License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
+ * 02111-1307, USA.
+ *
+ * Written by:
+ *     Dor Askayo <dor.askayo@gmail.com>
+ */
+
+#include "backends/native/meta-renderer-view-native.h"
+
+struct _MetaRendererViewNative
+{
+  MetaRendererView parent;
+};
+
+G_DEFINE_TYPE (MetaRendererViewNative, meta_renderer_view_native,
+               META_TYPE_RENDERER_VIEW);
+
+static void
+meta_renderer_view_native_init (MetaRendererViewNative *view_native)
+{
+}
+
+static void
+meta_renderer_view_native_class_init (MetaRendererViewNativeClass *klass)
+{
+}
diff --git a/src/backends/native/meta-renderer-view-native.h b/src/backends/native/meta-renderer-view-native.h
new file mode 100644
index 000000000..e42064006
--- /dev/null
+++ b/src/backends/native/meta-renderer-view-native.h
@@ -0,0 +1,34 @@
+/* -*- mode: C; c-file-style: "gnu"; indent-tabs-mode: nil; -*- */
+
+/*
+ * Copyright (C) 2020 Dor Askayo
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of the
+ * License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
+ * 02111-1307, USA.
+ *
+ * Written by:
+ *     Dor Askayo <dor.askayo@gmail.com>
+ */
+
+#ifndef META_RENDERER_VIEW_NATIVE_H
+#define META_RENDERER_VIEW_NATIVE_H
+
+#include "backends/meta-renderer-view.h"
+
+#define META_TYPE_RENDERER_VIEW_NATIVE (meta_renderer_view_native_get_type ())
+G_DECLARE_FINAL_TYPE (MetaRendererViewNative, meta_renderer_view_native,
+                      META, RENDERER_VIEW_NATIVE, MetaRendererView)
+
+#endif /* META_RENDERER_VIEW_NATIVE_H */
diff --git a/src/meson.build b/src/meson.build
index 13a69c1a6..0d1a78fc9 100644
--- a/src/meson.build
+++ b/src/meson.build
@@ -769,6 +769,8 @@ if have_native_backend
     'backends/native/meta-renderer-native-private.h',
     'backends/native/meta-renderer-native.c',
     'backends/native/meta-renderer-native.h',
+    'backends/native/meta-renderer-view-native.c',
+    'backends/native/meta-renderer-view-native.h',
     'backends/native/meta-seat-impl.c',
     'backends/native/meta-seat-impl.h',
     'backends/native/meta-seat-native.c',
-- 
2.36.1


From 855347e3d04f44c235089b6213518526e612dd66 Mon Sep 17 00:00:00 2001
From: Dor Askayo <dor.askayo@gmail.com>
Date: Sat, 4 Jul 2020 22:13:55 +0300
Subject: [PATCH 11/25] renderer-view/native: Allow synchronizing frame clock
 updates with actor updates

Allow per-view sychnronization of frame clock updates to updates
generated by a specified actor.

This uses the variable mode of ClutterFrameClock to either perform an
immediate update or a delayed update depending on whether the update
is performed in the context of the specified actor or a different
actor.

This approach allows minimum latency between updates of the actor and
updates of the view, and avoids updates of the view when the
specified actor has not updated.

If the specified actor is frozen or destroyed, the synchornization is
stopped as no further updates from the actor are expected.

For now, the ClutterFrameClock mode is always set to
CLUTTER_FRAME_CLOCK_MODE_FIXED and frame synchronization isn't enabled
since this is the preferred behavior when the refresh rate is fixed.
When support for variable refresh rate is added in the following
commits, CLUTTER_FRAME_CLOCK_MODE_VARIABLE and frame synchronization
will be activated.
---
 .../native/meta-renderer-view-native.c        | 110 ++++++++++++++++++
 .../native/meta-renderer-view-native.h        |   3 +
 2 files changed, 113 insertions(+)

diff --git a/src/backends/native/meta-renderer-view-native.c b/src/backends/native/meta-renderer-view-native.c
index 38fd0453d..f78179dbb 100644
--- a/src/backends/native/meta-renderer-view-native.c
+++ b/src/backends/native/meta-renderer-view-native.c
@@ -24,20 +24,130 @@
 
 #include "backends/native/meta-renderer-view-native.h"
 
+#include "clutter/clutter.h"
+#include "backends/meta-output.h"
+#include "backends/native/meta-renderer-native.h"
+
 struct _MetaRendererViewNative
 {
   MetaRendererView parent;
+
+  gboolean frame_sync_active;
+
+  ClutterActor *frame_sync_actor;
+  gulong frame_sync_actor_frozen_id;
+  gulong frame_sync_actor_destroy_id;
 };
 
 G_DEFINE_TYPE (MetaRendererViewNative, meta_renderer_view_native,
                META_TYPE_RENDERER_VIEW);
 
+static void
+meta_renderer_view_native_update_sync_mode (MetaRendererViewNative *view_native)
+{
+  ClutterFrameClock *frame_clock =
+    clutter_stage_view_get_frame_clock (CLUTTER_STAGE_VIEW (view_native));
+
+  clutter_frame_clock_set_mode (frame_clock, CLUTTER_FRAME_CLOCK_MODE_FIXED);
+  frame_sync_active = FALSE;
+}
+
+static void
+on_frame_sync_actor_frozen (ClutterActor           *actor,
+                            MetaRendererViewNative *view_native)
+{
+  meta_renderer_view_native_set_frame_sync_actor (view_native, NULL);
+}
+
+static void
+on_frame_sync_actor_destroyed (ClutterActor           *actor,
+                               MetaRendererViewNative *view_native)
+{
+  meta_renderer_view_native_set_frame_sync_actor (view_native, NULL);
+}
+
+static void
+meta_renderer_view_native_schedule_actor_update (ClutterStageView *stage_view,
+                                                 ClutterActor     *actor)
+{
+  MetaRendererViewNative *view_native = META_RENDERER_VIEW_NATIVE (stage_view);
+  ClutterFrameClock *frame_clock;
+
+  g_return_if_fail (actor != NULL);
+
+  frame_clock = clutter_stage_view_get_frame_clock (stage_view);
+
+  if (view_native->frame_sync_active &&
+      actor == view_native->frame_sync_actor)
+    clutter_frame_clock_schedule_update_now (frame_clock);
+  else
+    clutter_frame_clock_schedule_update (frame_clock);
+}
+
+void
+meta_renderer_view_native_set_frame_sync_actor (MetaRendererViewNative *view_native,
+                                                ClutterActor           *actor)
+{
+  if (G_LIKELY (actor == view_native->frame_sync_actor))
+    return;
+
+  if (view_native->frame_sync_actor)
+    {
+      g_clear_signal_handler (&view_native->frame_sync_actor_frozen_id,
+                              view_native->frame_sync_actor);
+      g_clear_signal_handler (&view_native->frame_sync_actor_destroy_id,
+                              view_native->frame_sync_actor);
+    }
+
+  if (actor)
+    {
+        view_native->frame_sync_actor_frozen_id =
+        g_signal_connect (actor, "frozen",
+                          G_CALLBACK (on_frame_sync_actor_frozen),
+                          view_native);
+        view_native->frame_sync_actor_destroy_id =
+        g_signal_connect (actor, "destroy",
+                          G_CALLBACK (on_frame_sync_actor_destroyed),
+                          view_native);
+    }
+
+  view_native->frame_sync_actor = actor;
+
+  meta_renderer_view_native_update_sync_mode (view_native);
+}
+
+static void
+meta_renderer_view_native_dispose (GObject *object)
+{
+  MetaRendererViewNative *view_native = META_RENDERER_VIEW_NATIVE (object);
+
+  if (view_native->frame_sync_actor)
+    {
+      g_clear_signal_handler (&view_native->frame_sync_actor_destroy_id,
+                              view_native->frame_sync_actor);
+      g_clear_signal_handler (&view_native->frame_sync_actor_frozen_id,
+                              view_native->frame_sync_actor);
+    }
+
+  G_OBJECT_CLASS (meta_renderer_view_native_parent_class)->dispose (object);
+}
+
 static void
 meta_renderer_view_native_init (MetaRendererViewNative *view_native)
 {
+  view_native->frame_sync_active = FALSE;
+  view_native->frame_sync_actor = NULL;
+  view_native->frame_sync_actor_frozen_id = 0;
+  view_native->frame_sync_actor_destroy_id = 0;
 }
 
 static void
 meta_renderer_view_native_class_init (MetaRendererViewNativeClass *klass)
 {
+  GObjectClass *object_class = G_OBJECT_CLASS (klass);
+  ClutterStageViewClass *clutter_stage_view_class = CLUTTER_STAGE_VIEW_CLASS (klass);
+
+  object_class->dispose = meta_renderer_view_native_dispose;
+
+  clutter_stage_view_class->schedule_actor_update = meta_renderer_view_native_schedule_actor_update;
 }
diff --git a/src/backends/native/meta-renderer-view-native.h b/src/backends/native/meta-renderer-view-native.h
index e42064006..b4ec1ebd8 100644
--- a/src/backends/native/meta-renderer-view-native.h
+++ b/src/backends/native/meta-renderer-view-native.h
@@ -31,4 +31,7 @@
 G_DECLARE_FINAL_TYPE (MetaRendererViewNative, meta_renderer_view_native,
                       META, RENDERER_VIEW_NATIVE, MetaRendererView)
 
+void meta_renderer_view_native_set_frame_sync_actor (MetaRendererViewNative *view_native,
+                                                     ClutterActor           *actor);
+
 #endif /* META_RENDERER_VIEW_NATIVE_H */
-- 
2.36.1


From edf09b7f7601a9a9b1410577c299f884d201edc9 Mon Sep 17 00:00:00 2001
From: Dor Askayo <dor.askayo@gmail.com>
Date: Sun, 16 Aug 2020 20:11:48 +0300
Subject: [PATCH 12/25] wayland/actor-surface: Schedule actor updates for frame
 callbacks

---
 src/wayland/meta-wayland-actor-surface.c | 3 ++-
 1 file changed, 2 insertions(+), 1 deletion(-)

diff --git a/src/wayland/meta-wayland-actor-surface.c b/src/wayland/meta-wayland-actor-surface.c
index b6d26fdc1..096b46aa2 100644
--- a/src/wayland/meta-wayland-actor-surface.c
+++ b/src/wayland/meta-wayland-actor-surface.c
@@ -307,7 +307,8 @@ meta_wayland_actor_surface_apply_state (MetaWaylandSurfaceRole  *surface_role,
       MetaBackend *backend = meta_get_backend ();
       ClutterActor *stage = meta_backend_get_stage (backend);
 
-      clutter_stage_schedule_update (CLUTTER_STAGE (stage));
+      clutter_stage_schedule_actor_update (CLUTTER_STAGE (stage),
+                                           CLUTTER_ACTOR (priv->actor));
     }
 
   meta_wayland_actor_surface_queue_frame_callbacks (actor_surface, pending);
-- 
2.36.1


From daa5983c67f1778e73ccb6af94c7eebd6a6c8059 Mon Sep 17 00:00:00 2001
From: Dor Askayo <dor.askayo@gmail.com>
Date: Sun, 16 Aug 2020 10:07:54 +0300
Subject: [PATCH 13/25] clutter/stage: Always schedule actor updates on redraw

When updates are scheduled in the context of specific actors,
already-scheduled updates may need to be rescheduled based on the
actor requesting the update.

Allow scheduling updates for actors when the stage is already
pending a redraw.
---
 clutter/clutter/clutter-stage.c | 21 +--------------------
 1 file changed, 1 insertion(+), 20 deletions(-)

diff --git a/clutter/clutter/clutter-stage.c b/clutter/clutter/clutter-stage.c
index 3e81655e0..f40df1017 100644
--- a/clutter/clutter/clutter-stage.c
+++ b/clutter/clutter/clutter-stage.c
@@ -127,8 +127,6 @@ struct _ClutterStagePrivate
 
   int update_freeze_count;
 
-  gboolean pending_finish_queue_redraws;
-
   GHashTable *pointer_devices;
   GHashTable *touch_sequences;
 
@@ -2548,19 +2546,7 @@ clutter_stage_queue_actor_redraw (ClutterStage             *stage,
   CLUTTER_NOTE (CLIPPING, "stage_queue_actor_redraw (actor=%s, clip=%p): ",
                 _clutter_actor_get_debug_name (actor), clip);
 
-  if (!priv->pending_finish_queue_redraws)
-    {
-      GList *l;
-
-      for (l = clutter_stage_peek_stage_views (stage); l; l = l->next)
-        {
-          ClutterStageView *view = l->data;
-
-          clutter_stage_view_schedule_update (view);
-        }
-
-      priv->pending_finish_queue_redraws = TRUE;
-    }
+  clutter_stage_schedule_actor_update (stage, actor);
 
   entry = g_hash_table_lookup (priv->pending_queue_redraws, actor);
 
@@ -2684,11 +2670,6 @@ clutter_stage_maybe_finish_queue_redraws (ClutterStage *stage)
 
   COGL_TRACE_BEGIN_SCOPED (ClutterStageFinishQueueRedraws, "FinishQueueRedraws");
 
-  if (!priv->pending_finish_queue_redraws)
-    return;
-
-  priv->pending_finish_queue_redraws = FALSE;
-
   g_hash_table_iter_init (&iter, priv->pending_queue_redraws);
   while (g_hash_table_iter_next (&iter, &key, &value))
     {
-- 
2.36.1


From 762c073e4de8afbeb1c40e6ffe2bcac2270b8618 Mon Sep 17 00:00:00 2001
From: Dor Askayo <dor.askayo@gmail.com>
Date: Tue, 17 Mar 2020 21:39:49 +0200
Subject: [PATCH 14/25] window: Allow indicating that variable refresh rate is
 supported

---
 src/core/window-private.h |  7 +++++++
 src/core/window.c         | 24 ++++++++++++++++++++++++
 2 files changed, 31 insertions(+)

diff --git a/src/core/window-private.h b/src/core/window-private.h
index 8d2d4a020..f337dfef8 100644
--- a/src/core/window-private.h
+++ b/src/core/window-private.h
@@ -562,6 +562,8 @@ struct _MetaWindow
   GFile *cgroup_path;
 
   unsigned int events_during_ping;
+
+  gboolean vrr_supported;
 };
 
 struct _MetaWindowClass
@@ -826,6 +828,11 @@ void meta_window_set_transient_for        (MetaWindow *window,
 void meta_window_set_opacity              (MetaWindow *window,
                                            guint8      opacity);
 
+void meta_window_set_vrr_supported (MetaWindow *window,
+                                    gboolean    vrr_supported);
+
+gboolean meta_window_get_vrr_supported (MetaWindow *window);
+
 void meta_window_handle_enter (MetaWindow  *window,
                                guint32      timestamp,
                                guint        root_x,
diff --git a/src/core/window.c b/src/core/window.c
index 95a8e33e0..175a01d34 100644
--- a/src/core/window.c
+++ b/src/core/window.c
@@ -2784,6 +2784,30 @@ meta_window_is_on_primary_monitor (MetaWindow *window)
   return window->monitor->is_primary;
 }
 
+/**
+ * meta_window_set_vrr_supported:
+ * @window: a #MetaWindow
+ * @vrr_supported: whether the window supports variable refresh rate
+ */
+void
+meta_window_set_vrr_supported (MetaWindow *window,
+                               gboolean    vrr_supported)
+{
+  window->vrr_supported = vrr_supported;
+}
+
+/**
+ * meta_window_get_vrr_supported:
+ * @window: a #MetaWindow
+ *
+ * Return value: %TRUE if the window supports variable refresh rate
+ */
+gboolean
+meta_window_get_vrr_supported (MetaWindow *window)
+{
+  return window->vrr_supported;
+}
+
 static void
 meta_window_get_tile_fraction (MetaWindow   *window,
                                MetaTileMode  tile_mode,
-- 
2.36.1


From c147ba960917650f6af4249534e43003609e421d Mon Sep 17 00:00:00 2001
From: Dor Askayo <dor.askayo@gmail.com>
Date: Tue, 17 Mar 2020 01:44:25 +0200
Subject: [PATCH 15/25] compositor/native: Request frame synchronization for
 compatible windows

---
 src/compositor/meta-compositor-native.c | 20 ++++++-
 src/compositor/meta-compositor-native.h |  3 ++
 src/compositor/meta-window-actor.c      | 69 +++++++++++++++++++++++++
 3 files changed, 91 insertions(+), 1 deletion(-)

diff --git a/src/compositor/meta-compositor-native.c b/src/compositor/meta-compositor-native.c
index bc17704e1..8c4c419d6 100644
--- a/src/compositor/meta-compositor-native.c
+++ b/src/compositor/meta-compositor-native.c
@@ -22,8 +22,10 @@
 
 #include "compositor/meta-compositor-native.h"
 
-#include "backends/meta-logical-monitor.h"
+#include "clutter/clutter.h"
+#include "backends/meta-output.h"
 #include "backends/native/meta-crtc-kms.h"
+#include "backends/native/meta-renderer-view-native.h"
 #include "compositor/meta-surface-actor-wayland.h"
 
 struct _MetaCompositorNative
@@ -31,6 +33,8 @@ struct _MetaCompositorNative
   MetaCompositorServer parent;
 
   MetaWaylandSurface *current_scanout_candidate;
+
+  MetaSurfaceActor *frame_sync_surface_actor;
 };
 
 G_DEFINE_TYPE (MetaCompositorNative, meta_compositor_native,
@@ -155,18 +159,32 @@ done:
 }
 #endif /* HAVE_WAYLAND */
 
+void
+meta_compositor_native_request_frame_sync (MetaCompositorNative *compositor_native,
+                                           MetaSurfaceActor     *surface_actor)
+{
+  compositor_native->frame_sync_surface_actor = surface_actor;
+}
+
 static void
 meta_compositor_native_before_paint (MetaCompositor   *compositor,
                                      ClutterStageView *stage_view)
 {
+  MetaCompositorNative *compositor_native = META_COMPOSITOR_NATIVE (compositor);
+  MetaRendererViewNative *view_native = META_RENDERER_VIEW_NATIVE (stage_view);
   MetaCompositorClass *parent_class;
 
 #ifdef HAVE_WAYLAND
   maybe_assign_primary_plane (compositor);
 #endif
 
+  compositor_native->frame_sync_surface_actor = NULL;
+
   parent_class = META_COMPOSITOR_CLASS (meta_compositor_native_parent_class);
   parent_class->before_paint (compositor, stage_view);
+
+  meta_renderer_view_native_set_frame_sync_actor (view_native,
+                                                  CLUTTER_ACTOR (compositor_native->frame_sync_surface_actor));
 }
 
 MetaCompositorNative *
diff --git a/src/compositor/meta-compositor-native.h b/src/compositor/meta-compositor-native.h
index 2b1c65208..dcb9c7dc1 100644
--- a/src/compositor/meta-compositor-native.h
+++ b/src/compositor/meta-compositor-native.h
@@ -27,6 +27,9 @@
 G_DECLARE_FINAL_TYPE (MetaCompositorNative, meta_compositor_native,
                       META, COMPOSITOR_NATIVE, MetaCompositor)
 
+void meta_compositor_native_request_frame_sync (MetaCompositorNative *compositor_native,
+                                                MetaSurfaceActor     *surface_actor);
+
 MetaCompositorNative * meta_compositor_native_new (MetaDisplay *display,
                                                    MetaBackend *backend);
 
diff --git a/src/compositor/meta-window-actor.c b/src/compositor/meta-window-actor.c
index ae1fa4d90..721656fd6 100644
--- a/src/compositor/meta-window-actor.c
+++ b/src/compositor/meta-window-actor.c
@@ -41,6 +41,11 @@
 #include "wayland/meta-wayland-surface.h"
 #endif
 
+#ifdef HAVE_NATIVE_BACKEND
+#include "backends/native/meta-backend-native.h"
+#include "compositor/meta-compositor-native.h"
+#endif
+
 typedef enum
 {
   INITIALLY_FROZEN,
@@ -1053,6 +1058,65 @@ meta_window_actor_sync_visibility (MetaWindowActor *self)
     }
 }
 
+#ifdef HAVE_NATIVE_BACKEND
+static gboolean
+meta_window_covers_view (MetaWindow       *window,
+                         ClutterStageView *stage_view)
+{
+  MetaRectangle view_layout;
+
+  clutter_stage_view_get_layout (stage_view, &view_layout);
+
+  return meta_rectangle_contains_rect (&window->buffer_rect,
+                                       &view_layout);
+}
+
+static void
+meta_window_actor_maybe_request_frame_sync (MetaWindowActor  *window_actor,
+                                            ClutterStageView *stage_view)
+{
+  MetaWindowActorPrivate *priv =
+    meta_window_actor_get_instance_private (window_actor);
+  MetaCompositor *compositor = priv->compositor;
+  MetaCompositorNative *compositor_native =
+    META_COMPOSITOR_NATIVE (compositor);
+  MetaWindow *window;
+  MetaSurfaceActor *surface_actor;
+
+  if (meta_compositor_is_unredirect_inhibited (compositor))
+    return;
+
+  if (meta_window_actor_is_frozen (window_actor))
+    return;
+
+  if (meta_window_actor_effect_in_progress (window_actor))
+    return;
+
+  if (clutter_actor_has_transitions (CLUTTER_ACTOR (window_actor)))
+    return;
+
+  window = meta_window_actor_get_meta_window (window_actor);
+  if (!window)
+    return;
+
+  if (!meta_window_get_vrr_supported (window))
+    return;
+
+  if (!meta_window_should_be_showing (window))
+    return;
+
+  if (!meta_window_covers_view (window, stage_view))
+    return;
+
+  surface_actor = meta_window_actor_get_surface (window_actor);
+  if (!surface_actor)
+    return;
+
+  meta_compositor_native_request_frame_sync (compositor_native,
+                                             surface_actor);
+}
+#endif /* HAVE_NATIVE_BACKEND */
+
 void
 meta_window_actor_before_paint (MetaWindowActor  *self,
                                 ClutterStageView *stage_view)
@@ -1061,6 +1125,11 @@ meta_window_actor_before_paint (MetaWindowActor  *self,
     return;
 
   META_WINDOW_ACTOR_GET_CLASS (self)->before_paint (self, stage_view);
+
+#ifdef HAVE_NATIVE_BACKEND
+  if (META_IS_BACKEND_NATIVE (meta_get_backend ()))
+    meta_window_actor_maybe_request_frame_sync (self, stage_view);
+#endif
 }
 
 void
-- 
2.36.1


From 077a852433bf672cb60780a45e485ace67a8574f Mon Sep 17 00:00:00 2001
From: Dor Askayo <dor.askayo@gmail.com>
Date: Tue, 4 Aug 2020 22:07:13 +0300
Subject: [PATCH 16/25] temp: assume every window supports VRR

---
 src/compositor/meta-window-actor.c | 4 ++--
 1 file changed, 2 insertions(+), 2 deletions(-)

diff --git a/src/compositor/meta-window-actor.c b/src/compositor/meta-window-actor.c
index 721656fd6..e5c58a15a 100644
--- a/src/compositor/meta-window-actor.c
+++ b/src/compositor/meta-window-actor.c
@@ -1099,8 +1099,8 @@ meta_window_actor_maybe_request_frame_sync (MetaWindowActor  *window_actor,
   if (!window)
     return;
 
-  if (!meta_window_get_vrr_supported (window))
-    return;
+  //if (!meta_window_get_vrr_supported (window))
+  //  return;
 
   if (!meta_window_should_be_showing (window))
     return;
-- 
2.36.1


From c1ff8260e983e57c0396713948d4dbb8bfadb478 Mon Sep 17 00:00:00 2001
From: Dor Askayo <dor.askayo@gmail.com>
Date: Tue, 17 Mar 2020 21:42:37 +0200
Subject: [PATCH 17/25] connector/kms: Detect variable refresh rate capability

The "vrr_capable" property indicates whether variable refresh rate is
supported for a connector.
---
 src/backends/native/meta-kms-connector.c | 7 +++++++
 src/backends/native/meta-kms-connector.h | 2 ++
 2 files changed, 9 insertions(+)

diff --git a/src/backends/native/meta-kms-connector.c b/src/backends/native/meta-kms-connector.c
index b7550e12e..dc906035b 100644
--- a/src/backends/native/meta-kms-connector.c
+++ b/src/backends/native/meta-kms-connector.c
@@ -298,6 +298,9 @@ state_set_properties (MetaKmsConnectorState *state,
                 META_KMS_CONNECTOR_PROP_PRIVACY_SCREEN_HW_STATE))
         set_privacy_screen (state, connector, prop,
                             drm_connector->prop_values[i]);
+      else if ((prop->flags & DRM_MODE_PROP_RANGE) &&
+               strcmp (prop->name, "vrr_capable") == 0)
+        state->vrr_capable = drm_connector->prop_values[i];
 
       drmModeFreeProperty (prop);
     }
@@ -541,6 +544,7 @@ meta_kms_connector_state_new (void)
   state = g_new0 (MetaKmsConnectorState, 1);
   state->suggested_x = -1;
   state->suggested_y = -1;
+  state->vrr_capable = FALSE;
 
   return state;
 }
@@ -636,6 +640,9 @@ meta_kms_connector_state_changes (MetaKmsConnectorState *state,
   if (!kms_modes_equal (state->modes, new_state->modes))
     return META_KMS_UPDATE_CHANGE_FULL;
 
+  if (state->vrr_capable != new_state->vrr_capable)
+    return META_KMS_UPDATE_CHANGE_FULL;
+
   if (state->privacy_screen_state != new_state->privacy_screen_state)
     return META_KMS_UPDATE_CHANGE_PRIVACY_SCREEN;
 
diff --git a/src/backends/native/meta-kms-connector.h b/src/backends/native/meta-kms-connector.h
index c2b763548..381edca97 100644
--- a/src/backends/native/meta-kms-connector.h
+++ b/src/backends/native/meta-kms-connector.h
@@ -59,6 +59,8 @@ typedef struct _MetaKmsConnectorState
   gboolean hotplug_mode_update;
 
   MetaMonitorTransform panel_orientation_transform;
+
+  gboolean vrr_capable;
 } MetaKmsConnectorState;
 
 META_EXPORT_TEST
-- 
2.36.1


From bba4a5066a1a7c1b611ea43dbcb81b3321eb4332 Mon Sep 17 00:00:00 2001
From: Dor Askayo <dor.askayo@gmail.com>
Date: Tue, 17 Mar 2020 22:17:59 +0200
Subject: [PATCH 18/25] update/kms: Allow setting CRTC properties

---
 .../native/meta-kms-impl-device-atomic.c      | 25 ++++++++
 .../native/meta-kms-impl-device-simple.c      | 60 +++++++++++++++++++
 src/backends/native/meta-kms-update-private.h |  9 +++
 src/backends/native/meta-kms-update.c         | 32 ++++++++++
 4 files changed, 126 insertions(+)

diff --git a/src/backends/native/meta-kms-impl-device-atomic.c b/src/backends/native/meta-kms-impl-device-atomic.c
index 73dd8e697..4353788b6 100644
--- a/src/backends/native/meta-kms-impl-device-atomic.c
+++ b/src/backends/native/meta-kms-impl-device-atomic.c
@@ -261,6 +261,21 @@ add_crtc_property (MetaKmsImplDevice  *impl_device,
   return TRUE;
 }
 
+static gboolean
+process_crtc_update (MetaKmsImplDevice  *impl_device,
+                     MetaKmsUpdate      *update,
+                     drmModeAtomicReq   *req,
+                     GArray             *blob_ids,
+                     gpointer            update_entry,
+                     gpointer            user_data,
+                     GError            **error)
+{
+  MetaKmsCrtcUpdate *crtc_update = update_entry;
+  MetaKmsCrtc *crtc = crtc_update->crtc;
+
+  return TRUE;
+}
+
 static gboolean
 process_mode_set (MetaKmsImplDevice  *impl_device,
                   MetaKmsUpdate      *update,
@@ -948,6 +963,16 @@ meta_kms_impl_device_atomic_process_update (MetaKmsImplDevice *impl_device,
                         &error))
     goto err;
 
+  if (!process_entries (impl_device,
+                        update,
+                        req,
+                        blob_ids,
+                        meta_kms_update_get_crtc_updates (update),
+                        NULL,
+                        process_crtc_update,
+                        &error))
+    goto err;
+
   if (!process_entries (impl_device,
                         update,
                         req,
diff --git a/src/backends/native/meta-kms-impl-device-simple.c b/src/backends/native/meta-kms-impl-device-simple.c
index ca4ffe245..4c257755a 100644
--- a/src/backends/native/meta-kms-impl-device-simple.c
+++ b/src/backends/native/meta-kms-impl-device-simple.c
@@ -180,6 +180,47 @@ set_connector_property (MetaKmsImplDevice     *impl_device,
   return TRUE;
 }
 
+static gboolean
+set_crtc_property (MetaKmsImplDevice  *impl_device,
+                   MetaKmsCrtc        *crtc,
+                   MetaKmsCrtcProp     prop,
+                   uint64_t            value,
+                   GError            **error)
+{
+  uint32_t prop_id;
+  int fd;
+  int ret;
+
+  prop_id = meta_kms_crtc_get_prop_id (crtc, prop);
+  if (!prop_id)
+    {
+      g_set_error (error, G_IO_ERROR, G_IO_ERROR_NOT_SUPPORTED,
+                   "Property (%s) not found on CRTC %u",
+                   meta_kms_crtc_get_prop_name (crtc, prop),
+                   meta_kms_crtc_get_id (crtc));
+      return FALSE;
+    }
+
+  fd = meta_kms_impl_device_get_fd (impl_device);
+
+  ret = drmModeObjectSetProperty (fd,
+                                  meta_kms_crtc_get_id (crtc),
+                                  DRM_MODE_OBJECT_CRTC,
+                                  prop_id,
+                                  value);
+  if (ret != 0)
+    {
+      g_set_error (error, G_IO_ERROR, g_io_error_from_errno (-ret),
+                   "Failed to set CRTC %u property %u: %s",
+                   meta_kms_crtc_get_id (crtc),
+                   prop_id,
+                   g_strerror (-ret));
+      return FALSE;
+    }
+
+  return TRUE;
+}
+
 static gboolean
 process_connector_update (MetaKmsImplDevice  *impl_device,
                           MetaKmsUpdate      *update,
@@ -253,6 +294,18 @@ process_connector_update (MetaKmsImplDevice  *impl_device,
   return TRUE;
 }
 
+static gboolean
+process_crtc_update (MetaKmsImplDevice  *impl_device,
+                     MetaKmsUpdate      *update,
+                     gpointer            update_entry,
+                     GError            **error)
+{
+  MetaKmsCrtcUpdate *crtc_update = update_entry;
+  MetaKmsCrtc *crtc = crtc_update->crtc;
+
+  return TRUE;
+}
+
 static CachedModeSet *
 cached_mode_set_new (GList                 *connectors,
                      const drmModeModeInfo *drm_mode,
@@ -1492,6 +1545,13 @@ meta_kms_impl_device_simple_process_update (MetaKmsImplDevice *impl_device,
                         &error))
     goto err;
 
+  if (!process_entries (impl_device,
+                        update,
+                        meta_kms_update_get_crtc_updates (update),
+                        process_crtc_update,
+                        &error))
+    goto err;
+
   if (!process_entries (impl_device,
                         update,
                         meta_kms_update_get_crtc_gammas (update),
diff --git a/src/backends/native/meta-kms-update-private.h b/src/backends/native/meta-kms-update-private.h
index a613cbc5d..ec7ca025f 100644
--- a/src/backends/native/meta-kms-update-private.h
+++ b/src/backends/native/meta-kms-update-private.h
@@ -84,6 +84,12 @@ typedef struct _MetaKmsConnectorUpdate
   } privacy_screen;
 } MetaKmsConnectorUpdate;
 
+typedef struct _MetaKmsCrtcUpdate
+{
+  MetaKmsCrtc *crtc;
+
+} MetaKmsCrtcUpdate;
+
 typedef struct _MetaKmsPageFlipListener
 {
   MetaKmsCrtc *crtc;
@@ -157,6 +163,9 @@ void meta_kms_update_drop_defunct_page_flip_listeners (MetaKmsUpdate *update);
 META_EXPORT_TEST
 GList * meta_kms_update_get_connector_updates (MetaKmsUpdate *update);
 
+META_EXPORT_TEST
+GList * meta_kms_update_get_crtc_updates (MetaKmsUpdate *update);
+
 META_EXPORT_TEST
 GList * meta_kms_update_get_crtc_gammas (MetaKmsUpdate *update);
 
diff --git a/src/backends/native/meta-kms-update.c b/src/backends/native/meta-kms-update.c
index 53fc92eb8..d2e912347 100644
--- a/src/backends/native/meta-kms-update.c
+++ b/src/backends/native/meta-kms-update.c
@@ -38,6 +38,7 @@ struct _MetaKmsUpdate
   GList *mode_sets;
   GList *plane_assignments;
   GList *connector_updates;
+  GList *crtc_updates;
   GList *crtc_gammas;
 
   MetaKmsCustomPageFlip *custom_page_flip;
@@ -404,6 +405,30 @@ meta_kms_update_set_crtc_gamma (MetaKmsUpdate  *update,
   update->crtc_gammas = g_list_prepend (update->crtc_gammas, gamma);
 }
 
+static MetaKmsCrtcUpdate *
+ensure_crtc_update (MetaKmsUpdate *update,
+                    MetaKmsCrtc   *crtc)
+{
+  GList *l;
+  MetaKmsCrtcUpdate *crtc_update;
+
+  for (l = update->crtc_updates; l; l = l->next)
+    {
+      crtc_update = l->data;
+
+      if (crtc_update->crtc == crtc)
+        return crtc_update;
+    }
+
+  crtc_update = g_new0 (MetaKmsCrtcUpdate, 1);
+  crtc_update->crtc = crtc;
+
+  update->crtc_updates = g_list_prepend (update->crtc_updates,
+                                         crtc_update);
+
+  return crtc_update;
+}
+
 void
 meta_kms_update_add_page_flip_listener (MetaKmsUpdate                       *update,
                                         MetaKmsCrtc                         *crtc,
@@ -635,6 +660,12 @@ meta_kms_update_get_connector_updates (MetaKmsUpdate *update)
   return update->connector_updates;
 }
 
+GList *
+meta_kms_update_get_crtc_updates (MetaKmsUpdate *update)
+{
+  return update->crtc_updates;
+}
+
 GList *
 meta_kms_update_get_crtc_gammas (MetaKmsUpdate *update)
 {
@@ -708,6 +739,7 @@ meta_kms_update_free (MetaKmsUpdate *update)
   g_list_free_full (update->page_flip_listeners,
                     (GDestroyNotify) meta_kms_page_flip_listener_free);
   g_list_free_full (update->connector_updates, g_free);
+  g_list_free_full (update->crtc_updates, g_free);
   g_list_free_full (update->crtc_gammas, (GDestroyNotify) meta_kms_crtc_gamma_free);
   g_clear_pointer (&update->custom_page_flip, meta_kms_custom_page_flip_free);
 
-- 
2.36.1


From 693ece7d2557066074550885b71936019f27dfe6 Mon Sep 17 00:00:00 2001
From: Dor Askayo <dor.askayo@gmail.com>
Date: Tue, 17 Mar 2020 21:44:15 +0200
Subject: [PATCH 19/25] crtc/kms: Allow setting the "VRR_ENABLED" property on a
 CRTC

Add the "VRR_ENABLED" CRTC propetry ID and a funtion to update its
value on a CRTC.
---
 src/backends/native/meta-kms-crtc-private.h   |  1 +
 src/backends/native/meta-kms-crtc.c           |  5 ++++
 .../native/meta-kms-impl-device-atomic.c      | 30 +++++++++++++++++++
 .../native/meta-kms-impl-device-simple.c      | 30 +++++++++++++++++++
 src/backends/native/meta-kms-update-private.h |  4 +++
 src/backends/native/meta-kms-update.c         | 15 ++++++++++
 src/backends/native/meta-kms-update.h         |  4 +++
 7 files changed, 89 insertions(+)

diff --git a/src/backends/native/meta-kms-crtc-private.h b/src/backends/native/meta-kms-crtc-private.h
index 65bda3f10..0742c1e89 100644
--- a/src/backends/native/meta-kms-crtc-private.h
+++ b/src/backends/native/meta-kms-crtc-private.h
@@ -30,6 +30,7 @@ typedef enum _MetaKmsCrtcProp
   META_KMS_CRTC_PROP_MODE_ID = 0,
   META_KMS_CRTC_PROP_ACTIVE,
   META_KMS_CRTC_PROP_GAMMA_LUT,
+  META_KMS_CRTC_PROP_VRR_ENABLED,
   META_KMS_CRTC_N_PROPS
 } MetaKmsCrtcProp;
 
diff --git a/src/backends/native/meta-kms-crtc.c b/src/backends/native/meta-kms-crtc.c
index e9bd9308b..b00ccca71 100644
--- a/src/backends/native/meta-kms-crtc.c
+++ b/src/backends/native/meta-kms-crtc.c
@@ -390,6 +390,11 @@ init_properties (MetaKmsCrtc       *crtc,
           .name = "GAMMA_LUT",
           .type = DRM_MODE_PROP_BLOB,
         },
+      [META_KMS_CRTC_PROP_VRR_ENABLED] =
+        {
+          .name = "VRR_ENABLED",
+          .type = DRM_MODE_PROP_RANGE,
+        },
     }
   };
 
diff --git a/src/backends/native/meta-kms-impl-device-atomic.c b/src/backends/native/meta-kms-impl-device-atomic.c
index 4353788b6..a62e7269d 100644
--- a/src/backends/native/meta-kms-impl-device-atomic.c
+++ b/src/backends/native/meta-kms-impl-device-atomic.c
@@ -273,6 +273,36 @@ process_crtc_update (MetaKmsImplDevice  *impl_device,
   MetaKmsCrtcUpdate *crtc_update = update_entry;
   MetaKmsCrtc *crtc = crtc_update->crtc;
 
+  if (crtc_update->vrr_mode.has_update &&
+      crtc_update->vrr_mode.is_active)
+    {
+      meta_topic (META_DEBUG_KMS,
+                  "[atomic] Setting VRR mode on CRTC %u (%s)",
+                  meta_kms_crtc_get_id (crtc),
+                  meta_kms_impl_device_get_path (impl_device));
+
+      if (!add_crtc_property (impl_device,
+                              crtc, req,
+                              META_KMS_CRTC_PROP_VRR_ENABLED,
+                              1,
+                              error))
+        return FALSE;
+    }
+  else if (crtc_update->vrr_mode.has_update)
+    {
+      meta_topic (META_DEBUG_KMS,
+                  "[atomic] Unsetting VRR mode on CRTC %u (%s)",
+                  meta_kms_crtc_get_id (crtc),
+                  meta_kms_impl_device_get_path (impl_device));
+
+      if (!add_crtc_property (impl_device,
+                              crtc, req,
+                              META_KMS_CRTC_PROP_VRR_ENABLED,
+                              0,
+                              error))
+        return FALSE;
+    }
+
   return TRUE;
 }
 
diff --git a/src/backends/native/meta-kms-impl-device-simple.c b/src/backends/native/meta-kms-impl-device-simple.c
index 4c257755a..ece02d56e 100644
--- a/src/backends/native/meta-kms-impl-device-simple.c
+++ b/src/backends/native/meta-kms-impl-device-simple.c
@@ -303,6 +303,36 @@ process_crtc_update (MetaKmsImplDevice  *impl_device,
   MetaKmsCrtcUpdate *crtc_update = update_entry;
   MetaKmsCrtc *crtc = crtc_update->crtc;
 
+  if (crtc_update->vrr_mode.has_update &&
+      crtc_update->vrr_mode.is_active)
+    {
+      meta_topic (META_DEBUG_KMS,
+                  "[simple] Setting VRR mode on CRTC %u (%s)",
+                  meta_kms_crtc_get_id (crtc),
+                  meta_kms_impl_device_get_path (impl_device));
+
+      if (!set_crtc_property (impl_device,
+                              crtc,
+                              META_KMS_CRTC_PROP_VRR_ENABLED,
+                              1,
+                              error))
+        return FALSE;
+    }
+  else if (crtc_update->vrr_mode.has_update)
+    {
+      meta_topic (META_DEBUG_KMS,
+                  "[simple] Unsetting VRR mode on CRTC %u (%s)",
+                  meta_kms_crtc_get_id (crtc),
+                  meta_kms_impl_device_get_path (impl_device));
+
+      if (!set_crtc_property (impl_device,
+                              crtc,
+                              META_KMS_CRTC_PROP_VRR_ENABLED,
+                              0,
+                              error))
+        return FALSE;
+    }
+
   return TRUE;
 }
 
diff --git a/src/backends/native/meta-kms-update-private.h b/src/backends/native/meta-kms-update-private.h
index ec7ca025f..223b2ec56 100644
--- a/src/backends/native/meta-kms-update-private.h
+++ b/src/backends/native/meta-kms-update-private.h
@@ -88,6 +88,10 @@ typedef struct _MetaKmsCrtcUpdate
 {
   MetaKmsCrtc *crtc;
 
+  struct {
+    gboolean has_update;
+    gboolean is_active;
+  } vrr_mode;
 } MetaKmsCrtcUpdate;
 
 typedef struct _MetaKmsPageFlipListener
diff --git a/src/backends/native/meta-kms-update.c b/src/backends/native/meta-kms-update.c
index d2e912347..9d3f9f4d2 100644
--- a/src/backends/native/meta-kms-update.c
+++ b/src/backends/native/meta-kms-update.c
@@ -429,6 +429,21 @@ ensure_crtc_update (MetaKmsUpdate *update,
   return crtc_update;
 }
 
+void
+meta_kms_update_set_vrr_mode (MetaKmsUpdate *update,
+                              MetaKmsCrtc   *crtc,
+                              gboolean       is_active)
+{
+  MetaKmsCrtcUpdate *crtc_update;
+
+  g_assert (!meta_kms_update_is_locked (update));
+  g_assert (meta_kms_crtc_get_device (crtc) == update->device);
+
+  crtc_update = ensure_crtc_update (update, crtc);
+  crtc_update->vrr_mode.has_update = TRUE;
+  crtc_update->vrr_mode.is_active = is_active;
+}
+
 void
 meta_kms_update_add_page_flip_listener (MetaKmsUpdate                       *update,
                                         MetaKmsCrtc                         *crtc,
diff --git a/src/backends/native/meta-kms-update.h b/src/backends/native/meta-kms-update.h
index f31e36aad..2f69c754b 100644
--- a/src/backends/native/meta-kms-update.h
+++ b/src/backends/native/meta-kms-update.h
@@ -123,6 +123,10 @@ void meta_kms_update_set_crtc_gamma (MetaKmsUpdate  *update,
                                      const uint16_t *green,
                                      const uint16_t *blue);
 
+void meta_kms_update_set_vrr_mode (MetaKmsUpdate *update,
+                                   MetaKmsCrtc   *crtc,
+                                   gboolean       is_active);
+
 void meta_kms_plane_assignment_set_fb_damage (MetaKmsPlaneAssignment *plane_assignment,
                                               const int              *rectangles,
                                               int                     n_rectangles);
-- 
2.36.1


From 15843e5c3753103387e1fab0f03f4453cb33311a Mon Sep 17 00:00:00 2001
From: Dor Askayo <dor.askayo@gmail.com>
Date: Tue, 17 Mar 2020 21:50:19 +0200
Subject: [PATCH 20/25] output/kms: Allow setting the variable refresh rate
 mode of an output

Add a function that enables variable refresh rate on a CRTC when it
is enabled and requested for the given output. If it isn't requested
or enabled for the output, it is disabled on the CRTC.

An output is considered capable of variable refresh rate if its
connector supports it.
---
 src/backends/meta-monitor-manager-private.h |  1 +
 src/backends/meta-output.c                  | 30 +++++++++++++++++++++
 src/backends/meta-output.h                  |  9 +++++++
 src/backends/native/meta-output-kms.c       | 23 ++++++++++++++++
 src/backends/native/meta-output-kms.h       |  3 +++
 5 files changed, 66 insertions(+)

diff --git a/src/backends/meta-monitor-manager-private.h b/src/backends/meta-monitor-manager-private.h
index edf7e4501..dc0d27de5 100644
--- a/src/backends/meta-monitor-manager-private.h
+++ b/src/backends/meta-monitor-manager-private.h
@@ -102,6 +102,7 @@ struct _MetaOutputAssignment
   gboolean     is_primary;
   gboolean     is_presentation;
   gboolean     is_underscanning;
+  gboolean     is_vrr_enabled;
 };
 
 /*
diff --git a/src/backends/meta-output.c b/src/backends/meta-output.c
index ed4807507..e816cb570 100644
--- a/src/backends/meta-output.c
+++ b/src/backends/meta-output.c
@@ -55,6 +55,9 @@ typedef struct _MetaOutputPrivate
 
   gboolean is_underscanning;
 
+  gboolean is_vrr_enabled;
+  gboolean is_vrr_requested;
+
   int backlight;
 } MetaOutputPrivate;
 
@@ -177,6 +180,31 @@ meta_output_is_underscanning (MetaOutput *output)
   return priv->is_underscanning;
 }
 
+gboolean
+meta_output_is_vrr_enabled (MetaOutput *output)
+{
+  MetaOutputPrivate *priv = meta_output_get_instance_private (output);
+
+  return priv->is_vrr_enabled;
+}
+
+void
+meta_output_set_vrr_requested (MetaOutput *output,
+                               int         vrr_requested)
+{
+  MetaOutputPrivate *priv = meta_output_get_instance_private (output);
+
+  priv->is_vrr_requested = vrr_requested;
+}
+
+gboolean
+meta_output_is_vrr_requested (MetaOutput *output)
+{
+  MetaOutputPrivate *priv = meta_output_get_instance_private (output);
+
+  return priv->is_vrr_requested;
+}
+
 void
 meta_output_set_backlight (MetaOutput *output,
                            int         backlight)
@@ -235,6 +263,7 @@ meta_output_assign_crtc (MetaOutput                 *output,
   priv->is_primary = output_assignment->is_primary;
   priv->is_presentation = output_assignment->is_presentation;
   priv->is_underscanning = output_assignment->is_underscanning;
+  priv->is_vrr_enabled = output_assignment->is_vrr_enabled;
 }
 
 void
@@ -468,6 +497,7 @@ meta_output_init (MetaOutput *output)
 {
   MetaOutputPrivate *priv = meta_output_get_instance_private (output);
 
+  priv->is_vrr_requested = FALSE;
   priv->backlight = -1;
 }
 
diff --git a/src/backends/meta-output.h b/src/backends/meta-output.h
index 6c90d7e69..066c7c74e 100644
--- a/src/backends/meta-output.h
+++ b/src/backends/meta-output.h
@@ -103,6 +103,8 @@ typedef struct _MetaOutputInfo
   gboolean supports_underscanning;
   gboolean supports_color_transform;
 
+  gboolean vrr_capable;
+
   /*
    * Get a new preferred mode on hotplug events, to handle dynamic guest
    * resizing.
@@ -178,6 +180,13 @@ gboolean meta_output_is_presentation (MetaOutput *output);
 META_EXPORT_TEST
 gboolean meta_output_is_underscanning (MetaOutput *output);
 
+gboolean meta_output_is_vrr_enabled (MetaOutput *output);
+
+void meta_output_set_vrr_requested (MetaOutput *output,
+                                    int         vrr_requested);
+
+gboolean meta_output_is_vrr_requested (MetaOutput *output);
+
 void meta_output_set_backlight (MetaOutput *output,
                                 int         backlight);
 
diff --git a/src/backends/native/meta-output-kms.c b/src/backends/native/meta-output-kms.c
index fb658f29d..fb4efa0a9 100644
--- a/src/backends/native/meta-output-kms.c
+++ b/src/backends/native/meta-output-kms.c
@@ -97,6 +97,27 @@ meta_output_kms_set_underscan (MetaOutputKms *output_kms,
     }
 }
 
+void
+meta_output_kms_set_vrr_mode (MetaOutputKms *output_kms,
+                              MetaKmsUpdate *kms_update)
+{
+  MetaOutput *output = META_OUTPUT (output_kms);
+  const MetaOutputInfo *output_info = meta_output_get_info (output);
+  MetaCrtc *crtc;
+  MetaKmsCrtc *kms_crtc;
+
+  if (!output_info->vrr_capable)
+    return;
+
+  crtc = meta_output_get_assigned_crtc (output);
+  kms_crtc = meta_crtc_kms_get_kms_crtc (META_CRTC_KMS (crtc));
+
+  meta_kms_update_set_vrr_mode (kms_update,
+                                kms_crtc,
+                                (meta_output_is_vrr_enabled (output) &&
+                                meta_output_is_vrr_requested (output)));
+}
+
 static MetaPrivacyScreenState
 meta_output_kms_get_privacy_screen_state (MetaOutput *output)
 {
@@ -405,6 +426,8 @@ meta_output_kms_new (MetaGpuKms        *gpu_kms,
   output_info->supports_underscanning =
     meta_kms_connector_is_underscanning_supported (kms_connector);
 
+  output_info->vrr_capable = connector_state->vrr_capable;
+
   meta_output_info_parse_edid (output_info, connector_state->edid_data);
 
   drm_connector_type = meta_kms_connector_get_connector_type (kms_connector);
diff --git a/src/backends/native/meta-output-kms.h b/src/backends/native/meta-output-kms.h
index 52acc6032..25199a728 100644
--- a/src/backends/native/meta-output-kms.h
+++ b/src/backends/native/meta-output-kms.h
@@ -40,6 +40,9 @@ void meta_output_kms_set_power_save_mode (MetaOutputKms *output_kms,
 void meta_output_kms_set_underscan (MetaOutputKms *output_kms,
                                     MetaKmsUpdate *kms_update);
 
+void meta_output_kms_set_vrr_mode (MetaOutputKms *output_kms,
+                                   MetaKmsUpdate *kms_update);
+
 gboolean meta_output_kms_can_clone (MetaOutputKms *output_kms,
                                     MetaOutputKms *other_output_kms);
 
-- 
2.36.1


From 3f2f1454be63050b0d43cf13dbbff49ca4e5d523 Mon Sep 17 00:00:00 2001
From: Dor Askayo <dor.askayo@gmail.com>
Date: Tue, 17 Mar 2020 21:53:44 +0200
Subject: [PATCH 21/25] renderer/native: Set the variable refresh rate mode on
 a mode set

---
 src/backends/native/meta-onscreen-native.c | 2 ++
 1 file changed, 2 insertions(+)

diff --git a/src/backends/native/meta-onscreen-native.c b/src/backends/native/meta-onscreen-native.c
index 36d6e291e..e0ddf7a83 100644
--- a/src/backends/native/meta-onscreen-native.c
+++ b/src/backends/native/meta-onscreen-native.c
@@ -533,6 +533,8 @@ meta_onscreen_native_set_crtc_mode (CoglOnscreen              *onscreen,
   meta_crtc_kms_set_mode (crtc_kms, kms_update);
   meta_output_kms_set_underscan (META_OUTPUT_KMS (onscreen_native->output),
                                  kms_update);
+  meta_output_kms_set_vrr_mode (META_OUTPUT_KMS (onscreen_native->output),
+                                kms_update);
 }
 
 static void
-- 
2.36.1


From 92a6c9bac7f5e7d5a85f177cac20c4733c9edad2 Mon Sep 17 00:00:00 2001
From: Dor Askayo <dor.askayo@gmail.com>
Date: Tue, 17 Mar 2020 20:57:41 +0200
Subject: [PATCH 22/25] monitor: Allow checking the state of variable refresh
 rate

A monitor is considered to have variable refresh rate support if its
main output supports it.
---
 src/backends/meta-monitor.c | 19 +++++++++++++++++++
 src/backends/meta-monitor.h |  4 ++++
 2 files changed, 23 insertions(+)

diff --git a/src/backends/meta-monitor.c b/src/backends/meta-monitor.c
index 46cb05a66..2abfb3ea6 100644
--- a/src/backends/meta-monitor.c
+++ b/src/backends/meta-monitor.c
@@ -358,6 +358,25 @@ meta_monitor_is_underscanning (MetaMonitor *monitor)
   return meta_output_is_underscanning (output);
 }
 
+gboolean
+meta_monitor_is_vrr_capable (MetaMonitor *monitor)
+{
+  const MetaOutputInfo *output_info =
+    meta_monitor_get_main_output_info (monitor);
+
+  return output_info->vrr_capable;
+}
+
+gboolean
+meta_monitor_is_vrr_enabled (MetaMonitor *monitor)
+{
+  MetaOutput *output;
+
+  output = meta_monitor_get_main_output (monitor);
+
+  return meta_output_is_vrr_enabled (output);
+}
+
 gboolean
 meta_monitor_is_laptop_panel (MetaMonitor *monitor)
 {
diff --git a/src/backends/meta-monitor.h b/src/backends/meta-monitor.h
index 066caa7f4..a63300cd0 100644
--- a/src/backends/meta-monitor.h
+++ b/src/backends/meta-monitor.h
@@ -118,6 +118,10 @@ gboolean meta_monitor_supports_underscanning (MetaMonitor *monitor);
 
 gboolean meta_monitor_is_underscanning (MetaMonitor *monitor);
 
+gboolean meta_monitor_is_vrr_capable (MetaMonitor *monitor);
+
+gboolean meta_monitor_is_vrr_enabled (MetaMonitor *monitor);
+
 gboolean meta_monitor_is_laptop_panel (MetaMonitor *monitor);
 
 gboolean meta_monitor_is_same_as (MetaMonitor *monitor,
-- 
2.36.1


From 21c3873088174255ef57b446ed7334e164f27540 Mon Sep 17 00:00:00 2001
From: Dor Askayo <dor.askayo@gmail.com>
Date: Tue, 17 Mar 2020 20:52:16 +0200
Subject: [PATCH 23/25] monitor-manager: Add variable refresh rate
 configuration

This allows enabling variable refresh rate on monitors that support it.

The configuration is persistent via monitors.xml and exposed in
DisplayConfig to be managed through DBus.
---
 .../org.gnome.Mutter.DisplayConfig.xml        |  7 +++++
 src/backends/meta-monitor-config-manager.c    |  9 ++++--
 src/backends/meta-monitor-config-manager.h    |  1 +
 src/backends/meta-monitor-config-migration.c  |  6 +++-
 src/backends/meta-monitor-config-store.c      | 30 +++++++++++++++++++
 src/backends/meta-monitor-manager.c           | 27 ++++++++++++++++-
 6 files changed, 75 insertions(+), 5 deletions(-)

diff --git a/data/dbus-interfaces/org.gnome.Mutter.DisplayConfig.xml b/data/dbus-interfaces/org.gnome.Mutter.DisplayConfig.xml
index af7cd6472..40f666793 100644
--- a/data/dbus-interfaces/org.gnome.Mutter.DisplayConfig.xml
+++ b/data/dbus-interfaces/org.gnome.Mutter.DisplayConfig.xml
@@ -336,6 +336,10 @@
 	    - "is-underscanning" (b): whether underscanning is enabled
 				      (absence of this means underscanning
 				      not being supported)
+	    - "is-vrr-enabled" (b): whether variable refresh rate is enabled
+	                            (absence of this means variable refresh
+	                            rate not being supported)
+
 	    - "max-screen-size" (ii): the maximum size a screen may have
 				      (absence of this means unlimited screen
 				      size)
@@ -454,6 +458,9 @@
 	        - "enable_underscanning" (b): enable monitor underscanning;
 					      may only be set when underscanning
 					      is supported (see GetCurrentState).
+	        - "enable_vrr" (b): enable variable refresh rate; may only be set
+	                            when variable refresh rate is supported (see
+	                            GetCurrentState).
 
 	@properties may effect the global monitor configuration state. Possible
 	properties are:
diff --git a/src/backends/meta-monitor-config-manager.c b/src/backends/meta-monitor-config-manager.c
index da3f1dd54..0fb36ef93 100644
--- a/src/backends/meta-monitor-config-manager.c
+++ b/src/backends/meta-monitor-config-manager.c
@@ -286,7 +286,8 @@ assign_monitor_crtc (MetaMonitor         *monitor,
     .output = output,
     .is_primary = assign_output_as_primary,
     .is_presentation = assign_output_as_presentation,
-    .is_underscanning = data->monitor_config->enable_underscanning
+    .is_underscanning = data->monitor_config->enable_underscanning,
+    .is_vrr_enabled = data->monitor_config->enable_vrr
   };
 
   g_ptr_array_add (data->crtc_assignments, crtc_assignment);
@@ -691,7 +692,8 @@ create_monitor_config (MetaMonitor     *monitor,
   *monitor_config = (MetaMonitorConfig) {
     .monitor_spec = meta_monitor_spec_clone (monitor_spec),
     .mode_spec = g_memdup2 (mode_spec, sizeof (MetaMonitorModeSpec)),
-    .enable_underscanning = meta_monitor_is_underscanning (monitor)
+    .enable_underscanning = meta_monitor_is_underscanning (monitor),
+    .enable_vrr = meta_monitor_is_vrr_enabled (monitor)
   };
 
   return monitor_config;
@@ -953,7 +955,8 @@ clone_monitor_config_list (GList *monitor_configs_in)
         .monitor_spec = meta_monitor_spec_clone (monitor_config_in->monitor_spec),
         .mode_spec = g_memdup2 (monitor_config_in->mode_spec,
                                 sizeof (MetaMonitorModeSpec)),
-        .enable_underscanning = monitor_config_in->enable_underscanning
+        .enable_underscanning = monitor_config_in->enable_underscanning,
+        .enable_vrr = monitor_config_in->enable_vrr
       };
       monitor_configs_out =
         g_list_append (monitor_configs_out, monitor_config_out);
diff --git a/src/backends/meta-monitor-config-manager.h b/src/backends/meta-monitor-config-manager.h
index a789e2f08..adbc3e575 100644
--- a/src/backends/meta-monitor-config-manager.h
+++ b/src/backends/meta-monitor-config-manager.h
@@ -34,6 +34,7 @@ typedef struct _MetaMonitorConfig
   MetaMonitorSpec *monitor_spec;
   MetaMonitorModeSpec *mode_spec;
   gboolean enable_underscanning;
+  gboolean enable_vrr;
 } MetaMonitorConfig;
 
 typedef struct _MetaLogicalMonitorConfig
diff --git a/src/backends/meta-monitor-config-migration.c b/src/backends/meta-monitor-config-migration.c
index 69c426cd7..10c26c4f0 100644
--- a/src/backends/meta-monitor-config-migration.c
+++ b/src/backends/meta-monitor-config-migration.c
@@ -74,6 +74,7 @@ typedef struct
   gboolean is_primary;
   gboolean is_presentation;
   gboolean is_underscanning;
+  gboolean is_vrr_enabled;
 } MetaOutputConfig;
 
 typedef struct _MetaLegacyMonitorsConfig
@@ -605,6 +606,8 @@ handle_text (GMarkupParseContext *context,
           parser->output.is_presentation = read_bool (text, text_len, error);
         else if (strcmp (parser->output_field, "underscanning") == 0)
           parser->output.is_underscanning = read_bool (text, text_len, error);
+        else if (strcmp (parser->output_field, "enable_vrr") == 0)
+          parser->output.is_vrr_enabled = read_bool (text, text_len, error);
         else
           g_assert_not_reached ();
         return;
@@ -697,7 +700,8 @@ create_monitor_config (MetaOutputKey    *output_key,
   *monitor_config = (MetaMonitorConfig) {
     .monitor_spec = monitor_spec,
     .mode_spec = mode_spec,
-    .enable_underscanning = output_config->is_underscanning
+    .enable_underscanning = output_config->is_underscanning,
+    .enable_vrr = output_config->is_vrr_enabled
   };
 
   if (!meta_verify_monitor_config (monitor_config, error))
diff --git a/src/backends/meta-monitor-config-store.c b/src/backends/meta-monitor-config-store.c
index 5d48ec2ea..a5fc83b46 100644
--- a/src/backends/meta-monitor-config-store.c
+++ b/src/backends/meta-monitor-config-store.c
@@ -167,6 +167,7 @@ typedef enum
   STATE_MONITOR_MODE_RATE,
   STATE_MONITOR_MODE_FLAG,
   STATE_MONITOR_UNDERSCANNING,
+  STATE_MONITOR_ENABLE_VRR,
   STATE_DISABLED,
   STATE_POLICY,
   STATE_STORES,
@@ -451,6 +452,10 @@ handle_start_element (GMarkupParseContext  *context,
           {
             parser->state = STATE_MONITOR_UNDERSCANNING;
           }
+	else if (g_str_equal (element_name, "enable-vrr"))
+          {
+            parser->state = STATE_MONITOR_ENABLE_VRR;
+          }
         else
           {
             g_set_error (error, G_MARKUP_ERROR, G_MARKUP_ERROR_UNKNOWN_ELEMENT,
@@ -544,6 +549,13 @@ handle_start_element (GMarkupParseContext  *context,
         return;
       }
 
+    case STATE_MONITOR_ENABLE_VRR:
+      {
+        g_set_error (error, G_MARKUP_ERROR, G_MARKUP_ERROR_UNKNOWN_ELEMENT,
+                     "Invalid element '%s' under enable-vrr", element_name);
+        return;
+      }
+
     case STATE_DISABLED:
       {
         if (!g_str_equal (element_name, "monitorspec"))
@@ -818,6 +830,14 @@ handle_end_element (GMarkupParseContext  *context,
         return;
       }
 
+    case STATE_MONITOR_ENABLE_VRR:
+      {
+        g_assert (g_str_equal (element_name, "enable-vrr"));
+
+        parser->state = STATE_MONITOR;
+        return;
+      }
+
     case STATE_MONITOR:
       {
         MetaLogicalMonitorConfig *logical_monitor_config;
@@ -1301,6 +1321,14 @@ handle_text (GMarkupParseContext *context,
         return;
       }
 
+    case STATE_MONITOR_ENABLE_VRR:
+      {
+        read_bool (text, text_len,
+                   &parser->current_monitor_config->enable_vrr,
+                   error);
+        return;
+      }
+
     case STATE_STORE:
       {
         MetaConfigStore store;
@@ -1476,6 +1504,8 @@ append_monitors (GString *buffer,
       g_string_append (buffer, "        </mode>\n");
       if (monitor_config->enable_underscanning)
         g_string_append (buffer, "        <underscanning>yes</underscanning>\n");
+      if (monitor_config->enable_vrr)
+        g_string_append (buffer, "        <enable-vrr>yes</enable-vrr>\n");
       g_string_append (buffer, "      </monitor>\n");
     }
 }
diff --git a/src/backends/meta-monitor-manager.c b/src/backends/meta-monitor-manager.c
index be99b4664..050c3019c 100644
--- a/src/backends/meta-monitor-manager.c
+++ b/src/backends/meta-monitor-manager.c
@@ -1977,6 +1977,15 @@ meta_monitor_manager_handle_get_current_state (MetaDBusDisplayConfig *skeleton,
                                  g_variant_new_boolean (is_underscanning));
         }
 
+      if (meta_monitor_is_vrr_capable (monitor))
+        {
+          gboolean vrr_enabled = meta_monitor_is_vrr_enabled (monitor);
+
+          g_variant_builder_add (&monitor_properties_builder, "{sv}",
+                                 "is-vrr-enabled",
+                                 g_variant_new_boolean (vrr_enabled));
+        }
+
       is_builtin = meta_monitor_is_laptop_panel (monitor);
       g_variant_builder_add (&monitor_properties_builder, "{sv}",
                              "is-builtin",
@@ -2296,6 +2305,8 @@ create_monitor_config_from_variant (MetaMonitorManager *manager,
   g_autoptr (GVariant) properties_variant = NULL;
   gboolean enable_underscanning = FALSE;
   gboolean set_underscanning = FALSE;
+  gboolean enable_vrr = FALSE;
+  gboolean set_enable_vrr = FALSE;
 
   g_variant_get (monitor_config_variant, "(ss@a{sv})",
                  &connector,
@@ -2331,6 +2342,19 @@ create_monitor_config_from_variant (MetaMonitorManager *manager,
         }
     }
 
+  set_enable_vrr =
+    g_variant_lookup (properties_variant, "enable_vrr", "b",
+                      &enable_vrr);
+  if (set_enable_vrr)
+    {
+      if (enable_vrr && !meta_monitor_is_vrr_capable (monitor))
+        {
+          g_set_error (error, G_IO_ERROR, G_IO_ERROR_FAILED,
+                       "Variable refresh rate requested but unsupported");
+	  return NULL;
+        }
+    }
+
   monitor_spec = meta_monitor_spec_clone (meta_monitor_get_spec (monitor));
 
   monitor_mode_spec = g_new0 (MetaMonitorModeSpec, 1);
@@ -2340,7 +2364,8 @@ create_monitor_config_from_variant (MetaMonitorManager *manager,
   *monitor_config = (MetaMonitorConfig) {
     .monitor_spec = monitor_spec,
     .mode_spec = monitor_mode_spec,
-    .enable_underscanning = enable_underscanning
+    .enable_underscanning = enable_underscanning,
+    .enable_vrr = enable_vrr
   };
 
   return monitor_config;
-- 
2.36.1


From d37e9779d7e0d207f239829158e8c4227f4248e8 Mon Sep 17 00:00:00 2001
From: Dor Askayo <dor.askayo@gmail.com>
Date: Fri, 20 Mar 2020 20:52:13 +0200
Subject: [PATCH 24/25] renderer/native: Allow queuing a mode set on a specific
 view

---
 src/backends/native/meta-onscreen-native.c      | 10 ++++++++++
 src/backends/native/meta-onscreen-native.h      |  3 +++
 .../native/meta-renderer-native-private.h       |  3 +++
 src/backends/native/meta-renderer-native.c      | 17 +++++++++++++++++
 4 files changed, 33 insertions(+)

diff --git a/src/backends/native/meta-onscreen-native.c b/src/backends/native/meta-onscreen-native.c
index e0ddf7a83..6285b97e2 100644
--- a/src/backends/native/meta-onscreen-native.c
+++ b/src/backends/native/meta-onscreen-native.c
@@ -406,6 +406,16 @@ custom_egl_stream_page_flip (gpointer custom_page_flip_data,
 }
 #endif /* HAVE_EGL_DEVICE */
 
+void
+meta_onscreen_native_queue_mode_set_on_view (CoglOnscreen     *onscreen,
+                                             MetaRendererView *view)
+{
+  MetaOnscreenNative *onscreen_native = META_ONSCREEN_NATIVE (onscreen);
+
+  meta_renderer_native_queue_mode_set_on_view (onscreen_native->renderer_native,
+                                               view);
+}
+
 void
 meta_onscreen_native_dummy_power_save_page_flip (CoglOnscreen *onscreen)
 {
diff --git a/src/backends/native/meta-onscreen-native.h b/src/backends/native/meta-onscreen-native.h
index 3a85ace26..bff4b6f6f 100644
--- a/src/backends/native/meta-onscreen-native.h
+++ b/src/backends/native/meta-onscreen-native.h
@@ -33,6 +33,9 @@ G_DECLARE_FINAL_TYPE (MetaOnscreenNative, meta_onscreen_native,
                       META, ONSCREEN_NATIVE,
                       CoglOnscreenEgl)
 
+void meta_onscreen_native_queue_mode_set_on_view (CoglOnscreen     *onscreen,
+                                                  MetaRendererView *view);
+
 void meta_renderer_native_release_onscreen (CoglOnscreen *onscreen);
 
 void meta_onscreen_native_finish_frame (CoglOnscreen *onscreen,
diff --git a/src/backends/native/meta-renderer-native-private.h b/src/backends/native/meta-renderer-native-private.h
index e2e133bd9..2b750793e 100644
--- a/src/backends/native/meta-renderer-native-private.h
+++ b/src/backends/native/meta-renderer-native-private.h
@@ -75,6 +75,9 @@ MetaGles3 * meta_renderer_native_get_gles3 (MetaRendererNative *renderer_native)
 MetaRendererNativeGpuData * meta_renderer_native_get_gpu_data (MetaRendererNative *renderer_native,
                                                                MetaGpuKms         *gpu_kms);
 
+void meta_renderer_native_queue_mode_set_on_view (MetaRendererNative *renderer_native,
+                                                  MetaRendererView   *view);
+
 gboolean meta_renderer_native_has_pending_mode_sets (MetaRendererNative *renderer_native);
 
 gboolean meta_renderer_native_has_pending_mode_set (MetaRendererNative *renderer_native);
diff --git a/src/backends/native/meta-renderer-native.c b/src/backends/native/meta-renderer-native.c
index fdfe4a35f..b84dd1702 100644
--- a/src/backends/native/meta-renderer-native.c
+++ b/src/backends/native/meta-renderer-native.c
@@ -1029,6 +1029,23 @@ _cogl_winsys_egl_vtable = {
   .context_init = meta_renderer_native_init_egl_context
 };
 
+void
+meta_renderer_native_queue_mode_set_on_view (MetaRendererNative *renderer_native,
+                                             MetaRendererView   *view)
+{
+  ClutterStageView *stage_view = CLUTTER_STAGE_VIEW (view);
+
+  if (g_list_find (renderer_native->pending_mode_set_views, stage_view))
+    return;
+
+  renderer_native->pending_mode_set_views =
+    g_list_prepend (renderer_native->pending_mode_set_views, stage_view);
+
+  renderer_native->pending_mode_set = TRUE;
+
+  meta_topic (META_DEBUG_KMS, "Queue mode set on a view");
+}
+
 static void
 meta_renderer_native_queue_modes_reset (MetaRendererNative *renderer_native)
 {
-- 
2.36.1


From a93682e0fafc47b232df8956745b53dca2ef59e5 Mon Sep 17 00:00:00 2001
From: Dor Askayo <dor.askayo@gmail.com>
Date: Mon, 17 Aug 2020 21:28:44 +0300
Subject: [PATCH 25/25] renderer-view/native: Update variable refresh rate mode
 on actor synchronization

If actor synchronization is set, request to activate VRR for the
relevant output, and set the ClutterFrameClock mode to
CLUTTER_FRAME_CLOCK_MODE_VARIABLE. The combination of the two allows
a monitor that supports VRR to refresh at the rate by which the actor
updates.

If actor synchronization is not set, request to deactivate VRR for the
relevant output, and set the ClutterFrameClock mode to
CLUTTER_FRAME_CLOCK_MODE_FIXED.

In case of a change in the requested VRR mode, queue a mode set to
actually apply it.
---
 .../native/meta-renderer-view-native.c        | 35 +++++++++++++++++--
 1 file changed, 33 insertions(+), 2 deletions(-)

diff --git a/src/backends/native/meta-renderer-view-native.c b/src/backends/native/meta-renderer-view-native.c
index f78179dbb..5a7a6d634 100644
--- a/src/backends/native/meta-renderer-view-native.c
+++ b/src/backends/native/meta-renderer-view-native.c
@@ -26,6 +26,7 @@
 
 #include "clutter/clutter.h"
 #include "backends/meta-output.h"
+#include "backends/native/meta-onscreen-native.h"
 #include "backends/native/meta-renderer-native.h"
 
 struct _MetaRendererViewNative
@@ -47,9 +48,39 @@ meta_renderer_view_native_update_sync_mode (MetaRendererViewNative *view_native)
 {
   ClutterFrameClock *frame_clock =
     clutter_stage_view_get_frame_clock (CLUTTER_STAGE_VIEW (view_native));
+  MetaRendererView *view = META_RENDERER_VIEW (view_native);
+  MetaOutput *output = meta_renderer_view_get_output (view);
+  gboolean should_request_vrr;
 
-  clutter_frame_clock_set_mode (frame_clock, CLUTTER_FRAME_CLOCK_MODE_FIXED);
-  frame_sync_active = FALSE;
+  should_request_vrr = view_native->frame_sync_actor != NULL;
+
+  if (should_request_vrr == meta_output_is_vrr_requested (output))
+    return;
+
+  if (should_request_vrr)
+    {
+      meta_output_set_vrr_requested (output, TRUE);
+      clutter_frame_clock_set_mode (frame_clock,
+                                    CLUTTER_FRAME_CLOCK_MODE_VARIABLE);
+      view_native->frame_sync_active = TRUE;
+    }
+  else
+    {
+      meta_output_set_vrr_requested (output, FALSE);
+      clutter_frame_clock_set_mode (frame_clock,
+                                    CLUTTER_FRAME_CLOCK_MODE_FIXED);
+      view_native->frame_sync_active = FALSE;
+    }
+
+  if (meta_output_is_vrr_enabled (output))
+    {
+      ClutterStageView *stage_view = CLUTTER_STAGE_VIEW (view);
+      CoglFramebuffer *framebuffer =
+        clutter_stage_view_get_onscreen (stage_view);
+      CoglOnscreen *onscreen = COGL_ONSCREEN (framebuffer);
+
+      meta_onscreen_native_queue_mode_set_on_view (onscreen, view);
+    }
 }
 
 static void
-- 
2.36.1

